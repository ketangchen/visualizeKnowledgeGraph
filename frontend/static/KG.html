<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>知识图谱可视化系统</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #e0f7fa 0%, #e8f5e9 100%);
            color: #263238;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .panel {
            width: 300px;
            background: linear-gradient(180deg, #ffffff 0%, #f5f7fa 100%);
            padding: 15px;
            overflow-y: auto;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            margin: 10px;
        }

        .visualization-panel {
            flex: 1;
            position: relative;
            margin: 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.85);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.05);
        }

        #graph-container {
            width: 100%;
            height: 100%;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .control-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4dd0e1 0%, #80deea 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            color: #263238;
        }

        .control-btn:hover {
            background: linear-gradient(135deg, #26c6da 0%, #4dd0e1 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #546e7a;
        }

        input, select, textarea {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #b2ebf2;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.8);
            color: #263238;
            font-size: 14px;
            transition: border 0.3s;
        }

        input:focus, select:focus, textarea:focus {
            border-color: #4dd0e1;
            outline: none;
            box-shadow: 0 0 0 2px rgba(77, 208, 225, 0.2);
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .btn-primary, .btn-secondary {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #66bb6a 0%, #81c784 100%);
            color: #ffffff;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(102, 187, 106, 0.3);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #43a047 0%, #66bb6a 100%);
            box-shadow: 0 3px 6px rgba(102, 187, 106, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #b0bec5 0%, #cfd8dc 100%);
            color: #263238;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #90a4ae 0%, #b0bec5 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f44336 0%, #e57373 100%);
            color: #ffffff;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(244, 67, 54, 0.3);
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #d32f2f 0%, #f44336 100%);
            box-shadow: 0 3px 6px rgba(244, 67, 54, 0.4);
        }

        .list-title {
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #e0f2f1;
            color: #2e7d32;
        }

        .entity-item {
            background: linear-gradient(135deg, #f1f8e9 0%, #e8f5e9 100%);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            border-left: 3px solid #81c784;
        }

        .entity-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.05);
        }

        .entity-info p {
            font-size: 12px;
            color: #607d8b;
            margin-top: 3px;
        }

        .entity-domain {
            font-size: 11px;
            color: #2e7d32;
            background: #e8f5e8;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            font-weight: normal;
        }

        .entity-actions {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .action-btn {
            font-size: 14px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .action-btn:hover {
            opacity: 1;
        }

        .edit-btn {
            color: #2e7d32;
        }

        .delete-btn {
            color: #e53935;
        }

        .copy-btn {
            color: #1976d2;
        }

        .no-data {
            color: #78909c;
            text-align: center;
            padding: 20px;
            font-style: italic;
        }

        .detail-header {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #e0f2f1;
            color: #2e7d32;
        }

        .detail-section {
            margin-bottom: 15px;
        }

        .detail-section h3 {
            font-size: 14px;
            color: #546e7a;
            margin-bottom: 5px;
        }

        .detail-content {
            font-size: 15px;
            padding: 5px;
            background: #f1f8e9;
            border-radius: 4px;
            color: #263238;
        }
        
        /* 可调整大小的描述框样式 */
        .resizable-description {
            position: relative;
            min-height: 60px;
            max-height: 200px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            border: 1px solid #c8e6c9;
            resize: vertical;
            overflow-y: auto;
            padding: 10px;
            padding-bottom: 50px; /* 为底部按钮留出空间 */
            background: #fafafa;
        }
        
        .resizable-description.expanded {
            max-height: 500px;
        }
        
        .description-text {
            word-wrap: break-word;
            line-height: 1.6;
            margin-bottom: 10px;
            color: #333;
            font-size: 14px;
        }
        
        .description-controls {
            position: absolute;
            bottom: 5px;
            right: 5px;
            display: flex;
            gap: 5px;
            z-index: 10;
            background: #fafafa;
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            pointer-events: auto;
        }
        
        /* 确保按钮在描述框拉伸时保持位置 */
        .resizable-description:focus-within .description-controls {
            position: absolute;
            bottom: 5px;
            right: 5px;
        }
        
        .description-controls button {
            padding: 3px 8px;
            font-size: 11px;
            border: 1px solid #4caf50;
            background: #4caf50;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            min-width: 40px;
            text-align: center;
        }
        
        .description-controls button:hover {
            background: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .description-controls .copy-btn {
            background: #2196f3;
            border-color: #2196f3;
        }
        
        .description-controls .copy-btn:hover {
            background: #1976d2;
        }

        /* 实体悬浮信息框样式 */
        .entity-tooltip {
            position: absolute;
            /* 1. 设置宽度（固定宽度或最大宽度） */
            width: 300px; /* 固定宽度（例如300px） */
            /* 或使用最大宽度（推荐，自适应内容）：
            max-width: 300px; */

            /* 2. 设置边框样式 */
            border: 2px solid #4dd0e1; /* 边框宽度、样式、颜色 */
            border-radius: 8px; /* 边框圆角（可选，让边角更圆润） */

            /* 以下为原有其他样式（保持不变） */
            padding: 10px;
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
            font-size: 14px;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            left: 0;
            top: 0;
            transform: translate(-50%, -50%);
        }

        .entity-tooltip h4 {
            margin: 0 0 5px 0;
            color: #2e7d32;
            font-size: 15px;
            border-bottom: 1px solid #e0f2f1;
            padding-bottom: 3px;
        }

        .entity-tooltip p {
            margin: 3px 0;
            color: #263238;
            font-size: 13px;
        }

        /* 显示悬浮框时的样式 */
        .entity-tooltip.visible {
            opacity: 1;
        }

        /* 关系边样式 - 带箭头 */
        .links line {
            stroke: #90a4ae;
            stroke-opacity: 0.6;
            transition: all 0.3s ease;
        }

        /* 箭头标记定义 */
        .arrowhead {
            fill: none;
            stroke: #90a4ae;
            stroke-width: 1.5px;
            stroke-opacity: 0.8;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        /* 节点样式修改：大实心圆 + 内部文字 */
        .nodes circle {
            stroke: #ffffff;
            stroke-width: 2px;
            fill: #00BFFF;
            r: 35; /* 增大节点半径为35px */
            transition: all 0.3s ease;
        }

        /* 节点文字样式：居中显示在圆内 */
        .nodes text {
            fill: #ffffff; /* 白色文字更清晰 */
            font-size: 9px; /* 增大字体 */
            font-weight: 500; /* 字体粗细 */
            text-anchor: middle;
            dominant-baseline: middle; /* 垂直居中 */
            pointer-events: none; /* 文字不阻碍点击 */
            transition: all 0.3s ease;
        }

        /* 关系文字样式 */
        .link-labels text {
            fill: #37474f; /* 更深的颜色 */
            font-size: 9px; /* 增大字体 */
            font-weight: 500; /* 字体粗细 */
            text-anchor: middle;
            transition: all 0.3s ease;
        }

        /* 实体点击高亮 - 黄色样式 */
        .highlighted circle {
            stroke: #ffca28; /* 黄色高亮边框 */
            stroke-width: 3px;
            animation: pulse 1.5s infinite;
        }

        .highlighted text {
            fill: #ffff00; /* 黄色 */
            font-weight: bold;
            font-size: 10px; /* 增大字体 */
        }

        /* 搜索结果高亮 - 与点击高亮保持一致 */
        .search-highlighted circle {
            stroke: #ffca28; /* 金色/黄色 */
            stroke-width: 3px;
            animation: pulse 1.5s infinite;
            fill: #66bb6a;
        }

        .search-highlighted text {
            fill: #ffff00; /* 黄色 */
            font-weight: bold;
            font-size: 10px; /* 与点击高亮保持一致 */
        }

        /* 搜索结果的关系高亮 */
        .search-highlighted-link {
            stroke: #ffca28 !important;
            stroke-width: 3px !important;
            stroke-opacity: 1 !important;
            animation: pulseLink 1.5s infinite;
        }

        /* 高亮状态的箭头 */
        .search-highlighted-arrow, .arrow-highlighted {
            fill: none !important;
            stroke: #ffca28 !important;
            stroke-width: 2px !important;
            stroke-opacity: 1 !important;
        }

        /* 搜索结果的关系标签高亮 - 与点击高亮保持一致 */
        .search-highlighted-link-label {
            fill: #800080 !important; /* 紫色 */
            font-weight: bold !important;
            font-size: 15px !important; /* 与点击高亮保持一致 */
        }

        /* 未涉及的元素降低可见性 */
        .faded {
            opacity: 0.3;
        }

        /* 关系点击高亮样式 */
        .link-highlighted {
            stroke: #ffca28 !important;
            stroke-width: 3px !important;
            stroke-opacity: 1 !important;
            animation: pulseLink 1.5s infinite;
        }

        .link-label-highlighted {
            fill: #800080 !important; /* 紫色 */
            font-weight: bold !important;
            font-size: 15px !important; /* 增大字体 */
        }

        /* 关系关联实体高亮 */
        .relation-entity-highlighted circle {
            stroke: #ffca28 !important;
            stroke-width: 3px !important;
            animation: pulse 1.5s infinite;
        }

        .relation-entity-highlighted text {
            fill: #ffff00 !important; /* 黄色 */
            font-weight: bold !important;
            font-size: 10px !important; /* 增大字体 */
        }

        @keyframes pulse {
            0% { stroke-width: 3px; }
            50% { stroke-width: 6px; }
            100% { stroke-width: 3px; }
        }

        @keyframes pulseLink {
            0% { stroke-width: 3px; }
            50% { stroke-width: 5px; }
            100% { stroke-width: 3px; }
        }



        .search-container {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            flex-direction: column;
        }

        .search-type-container {
            width: 100%;
            margin-bottom: 8px;
        }

        #search-type {
            width: 100%;
        }

        .search-input-group {
            display: flex;
            gap: 5px;
            width: 100%;
        }

        #search-input {
            flex: 1;
        }

        .search-results-info {
            color: #2e7d32;
            font-size: 12px;
            margin: -15px 0 15px 0;
            text-align: right;
            padding-right: 5px;
        }

        .file-operation-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .file-input-container {
            position: relative;
            width: 100%;
        }

        #file-upload {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        /* 关系编辑表单样式 */
        .relation-edit-form {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e0f2f1;
        }

        /* 实体编辑表单样式 */
        .entity-edit-form {
            margin-top: 15px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0f2f1;
        }

        .entity-edit-form .form-group {
            margin-bottom: 15px;
        }

        .entity-edit-form label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
        }

        .entity-edit-form input,
        .entity-edit-form select,
        .entity-edit-form textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .entity-edit-form input:focus,
        .entity-edit-form select:focus,
        .entity-edit-form textarea:focus {
            outline: none;
            border-color: #26a69a;
            box-shadow: 0 0 0 2px rgba(38, 166, 154, 0.2);
        }

        .entity-edit-form .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .entity-edit-form .btn-primary,
        .entity-edit-form .btn-secondary {
            flex: 1;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .entity-edit-form .btn-primary {
            background-color: #26a69a;
            color: white;
        }

        .entity-edit-form .btn-primary:hover {
            background-color: #1e8a7f;
        }

        .entity-edit-form .btn-secondary {
            background-color: #6c757d;
            color: white;
        }

        .entity-edit-form .btn-secondary:hover {
            background-color: #5a6268;
        }

        /* AI问答机器人样式 */
        .ai-chatbot {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .ai-chatbot:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4);
        }

        /* 史努比简约客服图标样式 */
        .snoopy-icon {
            position: relative;
            width: 50px;
            height: 50px;
            margin: auto;
        }

        .snoopy-head {
            position: absolute;
            width: 42px;
            height: 40px;
            background: #FFFFFF;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            top: 5px;
            left: 4px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            border: 2px solid #E0E0E0;
        }

        .snoopy-ears {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .ear {
            position: absolute;
            width: 12px;
            height: 16px;
            background: #FFFFFF;
            border-radius: 50% 50% 0 0;
            top: -1px;
            border: 2px solid #E0E0E0;
        }

        .left-ear {
            left: 6px;
            transform: rotate(-25deg);
        }

        .right-ear {
            right: 6px;
            transform: rotate(25deg);
        }

        .snoopy-eyes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .eye {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #000;
            border-radius: 50%;
            top: 16px;
            animation: blink 5s infinite;
        }

        .left-eye {
            left: 16px;
        }

        .right-eye {
            right: 16px;
        }

        @keyframes blink {
            0%, 90%, 100% { opacity: 1; }
            95% { opacity: 0; }
        }

        .snoopy-nose {
            position: absolute;
            width: 4px;
            height: 3px;
            background: #000;
            border-radius: 50%;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
        }

        .snoopy-mouth {
            position: absolute;
            width: 6px;
            height: 2px;
            background: #000;
            border-radius: 0 0 3px 3px;
            top: 28px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* 悬停时的动画效果 */
        .ai-chatbot:hover .snoopy-icon {
            transform: scale(1.15);
            transition: transform 0.3s ease;
        }

        .ai-chatbot:hover .snoopy-ears {
            animation: wiggle 0.6s ease-in-out;
        }

        .ai-chatbot:hover .snoopy-head {
            animation: bounce 0.8s ease-in-out;
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-8deg); }
            75% { transform: rotate(8deg); }
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-3px); }
        }

        /* 史努比简约动画 */
        .snoopy-icon {
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-2px); }
        }



        .ai-chat-window {
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 350px;
            height: 500px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .ai-chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-chat-title {
            font-weight: bold;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-chat-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ai-switch-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-switch-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
        }

        .ai-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-switch.active {
            background: #4CAF50;
        }

        .ai-switch-slider {
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            left: 3px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .ai-switch.active .ai-switch-slider {
            left: 29px;
        }

        .ai-switch-text {
            font-size: 10px;
            color: white;
            font-weight: bold;
            z-index: 1;
            transition: all 0.3s ease;
        }

        .ai-switch.active .ai-switch-text {
            color: white;
        }

        /* 标题中的史努比头像样式 */
        .snoopy-title-avatar {
            position: relative;
            width: 24px;
            height: 24px;
            background: #FFFFFF;
            border-radius: 50%;
            border: 1px solid #E0E0E0;
            flex-shrink: 0;
        }

        .snoopy-title-avatar .snoopy-head {
            position: absolute;
            width: 16px;
            height: 14px;
            background: #FFFFFF;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            top: 3px;
            left: 4px;
            border: 1px solid #E0E0E0;
        }

        .snoopy-title-avatar .snoopy-ears {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .snoopy-title-avatar .ear {
            position: absolute;
            width: 5px;
            height: 6px;
            background: #FFFFFF;
            border-radius: 50% 50% 0 0;
            top: 0;
            border: 1px solid #E0E0E0;
        }

        .snoopy-title-avatar .left-ear {
            left: 3px;
            transform: rotate(-20deg);
        }

        .snoopy-title-avatar .right-ear {
            right: 3px;
            transform: rotate(20deg);
        }

        .snoopy-title-avatar .snoopy-eyes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .snoopy-title-avatar .eye {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #000;
            border-radius: 50%;
            top: 6px;
        }

        .snoopy-title-avatar .left-eye {
            left: 6px;
        }

        .snoopy-title-avatar .right-eye {
            right: 6px;
        }

        .snoopy-title-avatar .snoopy-nose {
            position: absolute;
            width: 1.5px;
            height: 1px;
            background: #000;
            border-radius: 50%;
            top: 9px;
            left: 50%;
            transform: translateX(-50%);
        }

        .ai-chat-close {
            cursor: pointer;
            font-size: 20px;
            color: white;
        }

        .ai-chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: #f8f9fa;
        }

        .ai-message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
        }

        .ai-message.user {
            justify-content: flex-end;
        }

        .ai-message-content {
            max-width: 80%;
            padding: 10px 15px;
            border-radius: 18px;
            word-wrap: break-word;
        }

        .ai-message.user .ai-message-content {
            background: #667eea;
            color: white;
        }

        .ai-message.bot .ai-message-content {
            background: white;
            color: #333;
            border: 1px solid #e0e0e0;
        }

        .ai-message-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin: 0 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }

        .ai-message.user .ai-message-avatar {
            background: #667eea;
            color: white;
        }

        .ai-message.bot .ai-message-avatar {
            background: #764ba2;
            color: white;
            position: relative;
            overflow: hidden;
        }

        /* 史努比头像样式 */
        .snoopy-avatar {
            position: relative;
            width: 30px;
            height: 30px;
            background: #FFFFFF;
            border-radius: 50%;
            border: 2px solid #E0E0E0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .snoopy-avatar .snoopy-head {
            position: absolute;
            width: 20px;
            height: 18px;
            background: #FFFFFF;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            top: 4px;
            left: 5px;
            border: 1px solid #E0E0E0;
        }

        .snoopy-avatar .snoopy-ears {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .snoopy-avatar .ear {
            position: absolute;
            width: 6px;
            height: 8px;
            background: #FFFFFF;
            border-radius: 50% 50% 0 0;
            top: 0;
            border: 1px solid #E0E0E0;
        }

        .snoopy-avatar .left-ear {
            left: 4px;
            transform: rotate(-20deg);
        }

        .snoopy-avatar .right-ear {
            right: 4px;
            transform: rotate(20deg);
        }

        .snoopy-avatar .snoopy-eyes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .snoopy-avatar .eye {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #000;
            border-radius: 50%;
            top: 8px;
        }

        .snoopy-avatar .left-eye {
            left: 8px;
        }

        .snoopy-avatar .right-eye {
            right: 8px;
        }

        .snoopy-avatar .snoopy-nose {
            position: absolute;
            width: 2px;
            height: 1.5px;
            background: #000;
            border-radius: 50%;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
        }

        .ai-chat-input {
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            background: white;
        }

        .ai-input-container {
            display: flex;
            gap: 10px;
        }

        .ai-input-field {
            flex: 1;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
            font-size: 14px;
        }

        .ai-input-field:focus {
            border-color: #667eea;
        }

        .ai-send-btn {
            padding: 10px 15px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .ai-send-btn:hover {
            background: #5a6fd8;
        }

        .ai-send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .ai-typing {
            display: none;
            padding: 10px 15px;
            color: #666;
            font-style: italic;
        }

        .relation-item {
            margin-bottom: 10px;
            padding: 5px;
            background: #f1f8e9;
            border-radius: 4px;
        }

        /* 实体和关系类型选择下拉框样式 */
        .entity-select-container, .relation-type-select-container {
            position: relative;
        }

        .entity-dropdown, .relation-type-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #b2ebf2;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            display: none;
            margin-top: 2px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.05);
        }

        .entity-dropdown.visible, .relation-type-dropdown.visible {
            display: block;
        }

        .dropdown-item {
            padding: 8px 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .dropdown-item:hover {
            background-color: #e0f7fa;
        }

        .dropdown-item.active {
            background-color: #81c784;
            color: white;
        }

        /* 领域选择器样式 */
        .domain-selector-container {
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f1f8e9 0%, #e8f5e9 100%);
            border-radius: 8px;
            border: 1px solid #c8e6c9;
        }

        .domain-info {
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 4px;
            font-size: 12px;
            color: #2e7d32;
            text-align: center;
        }

        #domain-select {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #81c784;
            color: #2e7d32;
            font-weight: 500;
        }

        #domain-select:focus {
            border-color: #4caf50;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
        }

        /* 领域选择下拉框样式 */
        .domain-select-container {
            position: relative;
        }

        .domain-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #81c784;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            display: none;
            margin-top: 2px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.05);
        }

        .domain-dropdown.visible {
            display: block;
        }

        .domain-dropdown .dropdown-item {
            padding: 8px 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .domain-dropdown .dropdown-item:hover {
            background-color: #e0f7fa;
        }

        .domain-dropdown .dropdown-item.active {
            background-color: #81c784;
            color: white;
        }

        #domain-select-display {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #81c784;
            color: #2e7d32;
            font-weight: 500;
        }

        #domain-select-display:focus {
            border-color: #4caf50;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="panel left-panel">
            <!-- 文件操作区域 -->
            <div class="file-operation-group">
                <div class="file-input-container">
                    <button class="btn-secondary" style="width: 100%;">上传JSON文件</button>
                    <input type="file" id="file-upload" accept=".json">
                </div>

                <button id="save-current-data" class="btn-primary">保存文件</button>
                
                <button id="clear-all-data" class="btn-danger" style="width: 100%; margin-top: 10px;">一键清空数据</button>

                <div id="current-file-info" style="font-size: 12px; color: #546e7a; margin-top: -10px; margin-bottom: 10px; display: none;">
                    当前文件: <span id="current-file-name">-</span>
                </div>
            </div>

            <div class="form-section">
                <h3 id="entity-form-title" class="list-title">添加实体</h3>
                <div class="form-group">
                    <label for="entity-domain">图谱领域</label>
                    <select id="entity-domain">
                        <option value="default">默认领域</option>
                        <option value="technology">技术领域</option>
                        <option value="medicine">医学领域</option>
                        <option value="finance">金融领域</option>
                        <option value="education">教育领域</option>
                        <option value="culture">文化领域</option>
                        <option value="custom">自定义领域</option>
                    </select>
                    <input type="text" id="custom-domain" placeholder="输入自定义领域名称" style="display: none; margin-top: 5px; width: 100%;">
                </div>
                <div class="form-group">
                    <label for="entity-id">实体ID</label>
                    <input type="text" id="entity-id" placeholder="输入唯一ID">
                </div>
                <div class="form-group">
                    <label for="entity-name">实体名称</label>
                    <input type="text" id="entity-name" placeholder="输入实体名称">
                </div>
                <div class="form-group">
                    <label for="entity-desc">实体描述</label>
                    <textarea id="entity-desc" rows="3" placeholder="输入实体描述"></textarea>
                </div>
                <div class="btn-group">
                    <button id="add-entity" class="btn-primary">添加实体</button>
                    <button id="update-entity" class="btn-primary" style="display: none;">更新实体</button>
                    <button id="cancel-edit" class="btn-secondary" style="display: none;">取消</button>
                    <button id="clear-entity-form" class="btn-secondary">清空</button>
                </div>
            </div>

            <div class="form-section" style="margin-top: 30px;">
                <h3 class="list-title">添加关系</h3>
                <div class="form-group">
                    <label for="source-entity-display">源实体</label>
                    <div class="entity-select-container">
                        <input type="text" id="source-entity-display" placeholder="选择或搜索源实体">
                        <input type="hidden" id="source-entity" value="">
                        <div class="entity-dropdown" id="source-entity-dropdown"></div>
                    </div>
                </div>
                <div class="form-group">
                    <label for="target-entity-display">目标实体</label>
                    <div class="entity-select-container">
                        <input type="text" id="target-entity-display" placeholder="选择或搜索目标实体">
                        <input type="hidden" id="target-entity" value="">
                        <div class="entity-dropdown" id="target-entity-dropdown"></div>
                    </div>
                </div>
                <div class="form-group">
                    <label for="relation-type-display">关系类型</label>
                    <div class="relation-type-select-container">
                        <input type="text" id="relation-type-display" placeholder="输入或选择关系类型">
                        <input type="hidden" id="relation-type" value="">
                        <div class="relation-type-dropdown" id="relation-type-dropdown"></div>
                    </div>
                </div>
                <div class="btn-group">
                    <button id="add-relation" class="btn-primary">添加关系</button>
                    <button id="clear-relation-form" class="btn-secondary">清空</button>
                </div>
            </div>

            <div class="entity-list">
                <h3 class="list-title">实体列表</h3>
                <div id="entities-container">
                    <div class="no-data">暂无实体数据</div>
                </div>
            </div>
        </div>

        <div class="visualization-panel">
            <div id="graph-container"></div>
            <!-- 新增：实体悬浮信息框 -->
            <div id="entity-tooltip" class="entity-tooltip">
                <h4 id="tooltip-title"></h4>
                <p><strong>ID：</strong><span id="tooltip-id"></span></p>
                <p><strong>领域：</strong><span id="tooltip-domain"></span></p>
                <p><strong>描述：</strong><span id="tooltip-desc"></span></p>
            </div>
            <!-- 原有控制按钮 -->
            <div class="controls">
                <div class="control-btn" id="zoom-in" title="放大">+</div>
                <div class="control-btn" id="zoom-out" title="缩小">-</div>
                <div class="control-btn" id="fit-view" title="适配显示">⟲</div>
                <div class="control-btn" id="reset-view" title="重置布局">⟳</div>
            </div>
        </div>

        <div class="panel right-panel">
            <!-- 领域选择区域 -->
            <div class="domain-selector-container">
                <h3 class="list-title">领域筛选</h3>
                <div class="form-group">
                    <label for="domain-select">选择领域</label>
                    <div class="domain-select-container">
                        <input type="text" id="domain-select-display" placeholder="输入或选择领域">
                        <input type="hidden" id="domain-select" value="all">
                        <div class="domain-dropdown" id="domain-dropdown"></div>
                    </div>
                </div>
                <div class="domain-info">
                    <span id="current-domain-info">当前显示：所有领域</span>
                </div>
            </div>

            <div class="search-container">
                <!-- 搜索类型选择下拉框 -->
                <div class="search-type-container">
                    <select id="search-type">
                        <option value="entityId">实体ID</option>
                        <option value="entityName" selected>实体名称</option>
                        <option value="entityDesc">实体描述</option>
                        <option value="relation">关系类型</option>
                    </select>
                </div>
                <div class="search-input-group">
                    <input type="text" id="search-input" placeholder="请输入搜索内容...">
                    <button id="search-btn" class="btn-primary">搜索</button>
                </div>
            </div>
            <div id="search-results-info" class="search-results-info"></div>
            <div id="detail-view">
                <div class="no-data">选择一个实体或关系查看详情</div>
            </div>
        </div>
    </div>

    <!-- AI问答机器人 -->
    <div class="ai-chatbot" onclick="toggleAIChat()">
        <div class="snoopy-icon">
            <div class="snoopy-head"></div>
            <div class="snoopy-ears">
                <div class="ear left-ear"></div>
                <div class="ear right-ear"></div>
            </div>
            <div class="snoopy-eyes">
                <div class="eye left-eye"></div>
                <div class="eye right-eye"></div>
            </div>
            <div class="snoopy-nose"></div>
            <div class="snoopy-mouth"></div>
        </div>
    </div>

    <div class="ai-chat-window" id="aiChatWindow">
        <div class="ai-chat-header">
            <div class="ai-chat-title">
                <div class="snoopy-title-avatar">
                    <div class="snoopy-head"></div>
                    <div class="snoopy-ears">
                        <div class="ear left-ear"></div>
                        <div class="ear right-ear"></div>
                    </div>
                    <div class="snoopy-eyes">
                        <div class="eye left-eye"></div>
                        <div class="eye right-eye"></div>
                    </div>
                    <div class="snoopy-nose"></div>
                </div>
                史努比AI助手
            </div>
            <div class="ai-chat-controls">
                <div class="ai-switch-container">
                    <span class="ai-switch-label">AI模式</span>
                    <div class="ai-switch" id="aiSwitch" onclick="toggleAISwitch()">
                        <div class="ai-switch-slider" id="aiSwitchSlider"></div>
                        <div class="ai-switch-text" id="aiSwitchText">外部</div>
                    </div>
                </div>
            </div>
            <div class="ai-chat-close" onclick="toggleAIChat()">×</div>
        </div>
        <div class="ai-chat-messages" id="aiChatMessages">
            <div class="ai-message bot">
                <div class="ai-message-avatar">
                    <div class="snoopy-avatar">
                        <div class="snoopy-head"></div>
                        <div class="snoopy-ears">
                            <div class="ear left-ear"></div>
                            <div class="ear right-ear"></div>
                        </div>
                        <div class="snoopy-eyes">
                            <div class="eye left-eye"></div>
                            <div class="eye right-eye"></div>
                        </div>
                        <div class="snoopy-nose"></div>
                    </div>
                </div>
                <div class="ai-message-content">
                    您好！我是史努比AI助手！我可以帮您分析图谱数据、查找实体关系、回答关于知识图谱的问题。请问有什么可以为您服务的吗？
                </div>
            </div>
        </div>
        <div class="ai-typing" id="aiTyping">AI正在思考中...</div>
        <div class="ai-chat-input">
            <div class="ai-input-container">
                <input type="text" class="ai-input-field" id="aiInputField" placeholder="输入您的问题..." onkeypress="handleAIKeyPress(event)">
                <button class="ai-send-btn" onclick="sendAIMessage()" id="aiSendBtn">发送</button>
            </div>
        </div>
    </div>

    <script>
        // API基础URL
        const API_BASE_URL = '/api/kg';
        
        // API调用函数
        async function apiCall(endpoint, method = 'GET', data = null) {
            try {
                const options = {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                    }
                };
                
                if (data && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
                    options.body = JSON.stringify(data);
                }
                
                const response = await fetch(`${API_BASE_URL}${endpoint}`, options);
                const result = await response.json();
                
                if (result.ret === 0) {
                    return result;
                } else {
                    throw new Error(result.msg || 'API调用失败');
                }
            } catch (error) {
                console.error('API调用错误:', error);
                throw error;
            }
        }
        
        // 获取图谱数据
        async function loadGraphData() {
            try {
                const result = await apiCall('/data');
                graphData = result.data;
                
                // 确保数据包含领域信息
                graphData.nodes = graphData.nodes.map(node => ({
                    ...node,
                    domain: node.domain || 'default'
                }));
                
                graphData.links = graphData.links.map(link => ({
                    ...link,
                    domain: link.domain || 'default'
                }));
                
                console.log('从后端加载数据成功:', graphData);
                return true;
            } catch (error) {
                console.error('加载数据失败:', error);
                return false;
            }
        }
        
        // 创建实体
        async function createEntity(entityData) {
            try {
                const result = await apiCall('/entities', 'POST', entityData);
                console.log('创建实体成功:', result);
                return true;
            } catch (error) {
                console.error('创建实体失败:', error);
                return false;
            }
        }
        
        // 更新实体
        async function updateEntityAPI(entityId, entityData) {
            try {
                const result = await apiCall(`/entities/${entityId}`, 'PUT', entityData);
                console.log('更新实体成功:', result);
                return true;
            } catch (error) {
                console.error('更新实体失败:', error);
                return false;
            }
        }
        
        // 删除实体
        async function deleteEntityAPI(entityId) {
            try {
                const result = await apiCall(`/entities/${entityId}`, 'DELETE');
                console.log('删除实体成功:', result);
                return true;
            } catch (error) {
                console.error('删除实体失败:', error);
                return false;
            }
        }
        
        // 创建关系
        async function createRelationship(relationshipData) {
            try {
                const result = await apiCall('/relationships', 'POST', relationshipData);
                console.log('创建关系成功:', result);
                return result; // 返回API响应结果，包含关系ID
            } catch (error) {
                console.error('创建关系失败:', error);
                return false;
            }
        }
        
        // 删除关系
        async function deleteRelationshipAPI(relationshipId) {
            try {
                console.log('调用删除关系API，ID:', relationshipId);
                const result = await apiCall(`/relationships/${relationshipId}`, 'DELETE');
                console.log('删除关系成功:', result);
                return true;
            } catch (error) {
                console.error('删除关系失败:', error);
                console.error('错误详情:', error.message);
                return false;
            }
        }
        
        // 导入数据
        async function importGraphData(data) {
            try {
                const result = await apiCall('/import', 'POST', {
                    nodes: data.nodes,
                    links: data.links,
                    overwrite: true
                });
                console.log('导入数据成功:', result);
                return true;
            } catch (error) {
                console.error('导入数据失败:', error);
                return false;
            }
        }
        
        // 导出数据
        async function exportGraphData() {
            try {
                const result = await apiCall('/export');
                console.log('导出数据成功:', result);
                return result.data;
            } catch (error) {
                console.error('导出数据失败:', error);
                return null;
            }
        }

        // 清空所有数据
        async function clearAllDataAPI() {
            try {
                const result = await apiCall('/clear-all', 'POST');
                console.log('清空数据成功:', result);
                return result;
            } catch (error) {
                console.error('清空数据失败:', error);
                return null;
            }
        }

        // 全局变量
        let graphData = { nodes: [], links: [] };
        let svg = null;
        let simulation = null;
        let transform = d3.zoomIdentity;
        let zoom = null; // 缩放行为对象
        let selectedNode = null;
        let selectedLink = null; // 当前选中的关系
        let editingEntityId = null; // 当前编辑的实体ID
        let editingLinkIndex = -1; // 当前编辑的关系索引
        let searchResults = []; // 存储搜索结果
        let currentResultIndex = -1; // 当前显示的结果索引
        let lastSearchKeyword = ''; // 上一次搜索的关键字
        let lastSearchType = 'entityName'; // 上一次搜索的类型
        let linkElements = null; // 存储连线元素引用，用于高亮
        let linkLabelElements = null; // 存储连线标签引用，用于高亮
        let nodeGroups = null; // 存储节点组引用，用于高亮
        let arrowElements = null; // 存储箭头元素引用
        let currentFilePath = null; // 当前打开的文件路径
        let usedRelationTypes = new Set(); // 已使用的关系类型集合
        let currentDomain = 'all'; // 当前选中的领域
        let allGraphData = { nodes: [], links: [] }; // 存储所有数据
        let filteredGraphData = { nodes: [], links: [] }; // 存储筛选后的数据

        // DOM元素
        const entityDomainSelect = document.getElementById('entity-domain');
        const customDomainInput = document.getElementById('custom-domain');
        const entityIdInput = document.getElementById('entity-id');
        const entityNameInput = document.getElementById('entity-name');
        const entityDescInput = document.getElementById('entity-desc');
        const addEntityBtn = document.getElementById('add-entity');
        const updateEntityBtn = document.getElementById('update-entity');
        const cancelEditBtn = document.getElementById('cancel-edit');
        const clearEntityFormBtn = document.getElementById('clear-entity-form');
        const sourceEntityInput = document.getElementById('source-entity');
        const sourceEntityDisplay = document.getElementById('source-entity-display');
        const sourceEntityDropdown = document.getElementById('source-entity-dropdown');
        const targetEntityInput = document.getElementById('target-entity');
        const targetEntityDisplay = document.getElementById('target-entity-display');
        const targetEntityDropdown = document.getElementById('target-entity-dropdown');
        const relationTypeInput = document.getElementById('relation-type');
        const relationTypeDisplay = document.getElementById('relation-type-display');
        const relationTypeDropdown = document.getElementById('relation-type-dropdown');
        const addRelationBtn = document.getElementById('add-relation');
        const clearRelationFormBtn = document.getElementById('clear-relation-form');
        const entitiesContainer = document.getElementById('entities-container');
        const detailView = document.getElementById('detail-view');
        const searchInput = document.getElementById('search-input');
        const searchBtn = document.getElementById('search-btn');
        const searchTypeSelect = document.getElementById('search-type');
        const searchResultsInfo = document.getElementById('search-results-info');
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        const fitViewBtn = document.getElementById('fit-view');
        const resetViewBtn = document.getElementById('reset-view');
        const entityFormTitle = document.getElementById('entity-form-title');
        const fileUploadInput = document.getElementById('file-upload');
        const saveCurrentDataBtn = document.getElementById('save-current-data');
        const currentFileInfo = document.getElementById('current-file-info');
        const currentFileName = document.getElementById('current-file-name');
        const domainSelect = document.getElementById('domain-select');
        const domainSelectDisplay = document.getElementById('domain-select-display');
        const domainDropdown = document.getElementById('domain-dropdown');
        const currentDomainInfo = document.getElementById('current-domain-info');

        // 页面加载完成后初始化
        window.addEventListener('DOMContentLoaded', initialize);

        // 初始化函数
        async function initialize() {
            console.log('系统初始化开始');
            
            // 尝试从后端加载数据
            const loadSuccess = await loadGraphData();
            
            if (!loadSuccess) {
                console.log('从后端加载数据失败，使用默认数据');
                // 初始化默认数据
                graphData = {
                    nodes: [
                        { id: "1", name: "人工智能", description: "研究如何使机器模拟人类智能的科学", domain: "ai_domain" },
                        { id: "2", name: "机器学习", description: "人工智能的一个分支", domain: "ai_domain" },
                        { id: "3", name: "深度学习", description: "机器学习的一个分支", domain: "ai_domain" },
                        { id: "4", name: "神经网络", description: "受人脑结构启发的计算模型", domain: "ai_domain" },
                        { id: "5", name: "计算机视觉", description: "使计算机能够从图像中获取理解的领域", domain: "ai_domain" },
                        { id: "6", name: "心脏病", description: "心脏疾病的总称", domain: "medical_domain" },
                        { id: "7", name: "高血压", description: "血压持续升高的疾病", domain: "medical_domain" },
                        { id: "8", name: "糖尿病", description: "血糖代谢异常的疾病", domain: "medical_domain" },
                        { id: "9", name: "股票投资", description: "购买股票进行投资的行为", domain: "finance_domain" },
                        { id: "10", name: "基金理财", description: "通过基金进行理财投资", domain: "finance_domain" },
                        { id: "11", name: "在线教育", description: "通过网络进行的教育活动", domain: "education_domain" },
                        { id: "12", name: "编程语言", description: "用于编写计算机程序的语言", domain: "tech_domain" }
                    ],
                    links: [
                        { source: "1", target: "2", type: "包含", domain: "ai_domain" },
                        { source: "2", target: "3", type: "包含", domain: "ai_domain" },
                        { source: "3", target: "4", type: "基于", domain: "ai_domain" },
                        { source: "1", target: "5", type: "包含", domain: "ai_domain" },
                        { source: "5", target: "3", type: "应用", domain: "ai_domain" },
                        { source: "6", target: "7", type: "相关", domain: "medical_domain" },
                        { source: "7", target: "8", type: "并发症", domain: "medical_domain" },
                        { source: "9", target: "10", type: "替代", domain: "finance_domain" },
                        { source: "11", target: "12", type: "使用", domain: "education_domain" },
                        { source: "1", target: "12", type: "应用", domain: "ai_domain" }
                    ]
                };
            }

            // 初始化数据存储
            allGraphData = { ...graphData };
            filteredGraphData = { ...graphData };

            // 初始化已使用的关系类型集合
            updateUsedRelationTypes();

            updateEntityDropdowns();
            updateRelationTypeDropdown();
            renderEntityList();
            initializeGraph();
            setupEventListeners();
            // 初始化实体表单默认值
            populateDefaultEntityValues();
            
            // 初始化领域选择器
            initializeDomainSelector();
            
            // 设置初始显示值
            domainSelectDisplay.value = '所有领域';
            
            // 初始化AI开关状态（默认使用外部AI）
            const aiSwitch = document.getElementById('aiSwitch');
            const aiSwitchText = document.getElementById('aiSwitchText');
            aiSwitch.classList.add('active');
            aiSwitchText.textContent = '外部';
            
            console.log('系统初始化完成');
        }

        // 初始化领域选择器
        function initializeDomainSelector() {
            // 更新领域下拉框
            updateDomainDropdown();
            
            // 更新领域信息显示
            updateDomainInfo();
            
            // 添加领域选择事件监听
            domainSelectDisplay.addEventListener('focus', () => {
                domainDropdown.classList.add('visible');
            });

            domainSelectDisplay.addEventListener('input', () => {
                const inputValue = domainSelectDisplay.value.trim();
                const filtered = filterDomains(inputValue);
                updateDomainDropdown(filtered);
                domainDropdown.classList.add('visible');
            });

            // 失去焦点时保存自定义输入
            domainSelectDisplay.addEventListener('blur', () => {
                const inputValue = domainSelectDisplay.value.trim();
                if (inputValue) {
                    domainSelect.value = inputValue;
                    currentDomain = inputValue;
                    setTimeout(() => {
                        domainDropdown.classList.remove('visible');
                    }, 200);
                }
            });

            // 点击其他区域关闭下拉框
            document.addEventListener('click', (event) => {
                if (!event.target.closest('.domain-select-container')) {
                    domainDropdown.classList.remove('visible');
                }
            });
        }

        // 根据领域筛选数据
        function filterDataByDomain() {
            if (currentDomain === 'all') {
                // 显示所有数据
                filteredGraphData = { ...allGraphData };
            } else {
                // 筛选指定领域的实体
                const filteredNodes = allGraphData.nodes.filter(node => 
                    node.domain === currentDomain
                );
                
                // 获取筛选出的实体的ID集合
                const filteredNodeIds = new Set(filteredNodes.map(node => node.id));
                
                // 找到所有与筛选实体有关系的实体ID
                const relatedNodeIds = new Set(filteredNodeIds);
                
                // 遍历所有关系，找到与筛选实体相关的所有实体
                allGraphData.links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    
                    // 如果关系的源实体或目标实体在筛选结果中，则包含整个关系
                    if (filteredNodeIds.has(sourceId) || filteredNodeIds.has(targetId)) {
                        relatedNodeIds.add(sourceId);
                        relatedNodeIds.add(targetId);
                    }
                });
                
                // 获取所有相关实体
                const allRelatedNodes = allGraphData.nodes.filter(node => 
                    relatedNodeIds.has(node.id)
                );
                
                // 获取所有相关关系
                const allRelatedLinks = allGraphData.links.filter(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    return relatedNodeIds.has(sourceId) && relatedNodeIds.has(targetId);
                });
                
                filteredGraphData = {
                    nodes: allRelatedNodes,
                    links: allRelatedLinks
                };
            }
            
            // 更新当前使用的数据
            graphData = filteredGraphData;
            
            // 更新已使用的关系类型集合
            updateUsedRelationTypes();
            
            // 更新界面
            updateEntityDropdowns();
            updateRelationTypeDropdown();
            renderEntityList();
            reloadGraph();
            
            // 重置详情视图
            detailView.innerHTML = '<div class="no-data">选择一个实体或关系查看详情</div>';
            resetSearchState();
            
            // 更新领域下拉框
            updateDomainDropdown();
            
            console.log(`领域筛选完成：${currentDomain}，实体数：${graphData.nodes.length}，关系数：${graphData.links.length}`);
        }

        // 获取当前数据中的所有领域
        function getAvailableDomains() {
            const domains = new Set();
            
            // 从实体中获取领域
            graphData.nodes.forEach(node => {
                if (node.domain) {
                    domains.add(node.domain);
                }
            });
            
            // 从关系中获取领域
            graphData.links.forEach(link => {
                if (link.domain) {
                    domains.add(link.domain);
                }
            });
            
            return Array.from(domains).sort();
        }

        // 过滤领域
        function filterDomains(keyword) {
            const availableDomains = getAvailableDomains();
            
            if (!keyword) {
                return availableDomains;
            }

            const lowerKeyword = keyword.toLowerCase();
            return availableDomains.filter(domain =>
                domain.toLowerCase().includes(lowerKeyword)
            );
        }

        // 更新领域下拉框
        function updateDomainDropdown(filteredDomains = null) {
            domainDropdown.innerHTML = '';

            const domains = filteredDomains || getAvailableDomains();

            if (domains.length === 0) {
                const emptyItem = document.createElement('div');
                emptyItem.className = 'dropdown-item';
                emptyItem.textContent = '暂无领域数据';
                emptyItem.style.cursor = 'default';
                emptyItem.style.opacity = '0.7';
                domainDropdown.appendChild(emptyItem);
                return;
            }

            // 添加"所有领域"选项
            const allItem = document.createElement('div');
            allItem.className = 'dropdown-item';
            allItem.textContent = '所有领域';
            allItem.dataset.domain = 'all';
            allItem.addEventListener('click', () => {
                domainSelect.value = 'all';
                domainSelectDisplay.value = '所有领域';
                currentDomain = 'all';
                filterDataByDomain();
                updateDomainInfo();
                domainDropdown.classList.remove('visible');
            });
            domainDropdown.appendChild(allItem);

            // 添加领域选项
            domains.forEach(domain => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                item.textContent = domain;
                item.dataset.domain = domain;

                item.addEventListener('click', () => {
                    domainSelect.value = domain;
                    domainSelectDisplay.value = domain;
                    currentDomain = domain;
                    filterDataByDomain();
                    updateDomainInfo();
                    domainDropdown.classList.remove('visible');
                });

                domainDropdown.appendChild(item);
            });
        }

        // 更新领域信息显示
        function updateDomainInfo() {
            const domainName = currentDomain === 'all' ? '所有领域' : currentDomain;
            currentDomainInfo.textContent = `当前显示：${domainName} (${graphData.nodes.length}个实体，${graphData.links.length}个关系)`;
        }

        // 更新已使用的关系类型集合
        function updateUsedRelationTypes() {
            usedRelationTypes.clear();
            graphData.links.forEach(link => {
                usedRelationTypes.add(link.type);
            });
        }

        // 更新关系类型下拉框
        function updateRelationTypeDropdown() {
            relationTypeDropdown.innerHTML = '';

            const relationTypes = Array.from(usedRelationTypes).sort();

            if (relationTypes.length === 0) {
                const emptyItem = document.createElement('div');
                emptyItem.className = 'dropdown-item';
                emptyItem.textContent = '暂无关系类型';
                emptyItem.style.cursor = 'default';
                emptyItem.style.opacity = '0.7';
                relationTypeDropdown.appendChild(emptyItem);
                return;
            }

            relationTypes.forEach(type => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                item.textContent = type;
                item.dataset.type = type;

                item.addEventListener('click', () => {
                    relationTypeInput.value = type;
                    relationTypeDisplay.value = type;
                    relationTypeDropdown.classList.remove('visible');
                });

                relationTypeDropdown.appendChild(item);
            });
        }

        // 过滤关系类型
        function filterRelationTypes(keyword) {
            if (!keyword) {
                return Array.from(usedRelationTypes).sort();
            }

            const lowerKeyword = keyword.toLowerCase();
            return Array.from(usedRelationTypes).filter(type =>
                type.toLowerCase().includes(lowerKeyword)
            );
        }

        // ------------------------------
        // 文件上传与保存功能
        // ------------------------------
        function setupFileEventListeners() {
            // 上传JSON文件 - 修复的关键部分
            fileUploadInput.addEventListener('change', handleFileUpload);

            // 为上传按钮添加点击事件，触发文件选择
            document.querySelector('.file-input-container .btn-secondary').addEventListener('click', () => {
                fileUploadInput.click();
            });

            // 保存当前数据到本地
            saveCurrentDataBtn.addEventListener('click', saveCurrentData);
        }

        async function handleFileUpload(event) {
            // 确保有文件被选择
            if (!event.target.files || event.target.files.length === 0) {
                console.log('未选择文件');
                return;
            }

            const file = event.target.files[0];
            console.log('选择的文件:', file);

            if (!file.name.endsWith('.json')) {
                alert('请上传JSON格式的文件');
                fileUploadInput.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onloadstart = () => {
                console.log('开始读取文件...');
            };

            reader.onload = async function(e) {
                try {
                    console.log('文件读取完成，开始解析');
                    const importedData = JSON.parse(e.target.result);

                    if (!importedData.nodes || !importedData.links ||
                        !Array.isArray(importedData.nodes) || !Array.isArray(importedData.links)) {
                        throw new Error('JSON文件格式不正确，需包含nodes和links数组');
                    }

                    const validNodes = importedData.nodes.every(node =>
                        node.id !== undefined && node.name !== undefined
                    );
                    if (!validNodes) {
                        throw new Error('节点数据不完整，每个节点需包含id和name字段');
                    }

                    const validLinks = importedData.links.every(link =>
                        link.source !== undefined && link.target !== undefined && link.type !== undefined
                    );
                    if (!validLinks) {
                        throw new Error('关系数据不完整，每个关系需包含source、target和type字段');
                    }

                    // 处理导入的数据，确保包含领域信息
                    const processedData = {
                        nodes: importedData.nodes.map(node => ({
                            ...node,
                            domain: node.domain || 'default'
                        })),
                        links: importedData.links.map(link => ({
                            ...link,
                            domain: link.domain || 'default'
                        }))
                    };

                    // 调用后端API导入数据
                    const success = await importGraphData(processedData);
                    if (success) {
                        // 重新从后端加载数据
                        await loadGraphData();
                        
                        // 更新数据存储
                        allGraphData = { ...graphData };
                        filteredGraphData = { ...graphData };
                        
                        currentFilePath = file.name;
                        currentFileName.textContent = file.name;
                        currentFileInfo.style.display = 'block';

                        // 更新已使用的关系类型
                        updateUsedRelationTypes();

                        updateEntityDropdowns();
                        updateRelationTypeDropdown();
                        renderEntityList();
                        reloadGraph();
                        detailView.innerHTML = '<div class="no-data">数据导入成功，请选择实体或关系查看详情</div>';
                        resetSearchState();
                        // 更新实体表单默认值
                        populateDefaultEntityValues();
                        // 更新领域信息显示
                        updateDomainInfo();
                        // 更新领域下拉框
                        updateDomainDropdown();
                        alert(`数据导入成功！共导入 ${graphData.nodes.length} 个实体和 ${graphData.links.length} 个关系`);
                    } else {
                        alert('数据导入失败，请检查网络连接');
                    }
                } catch (error) {
                    console.error('文件解析失败：', error);
                    alert(`导入失败：${error.message}`);
                } finally {
                    // 重置文件输入，允许重复选择同一文件
                    fileUploadInput.value = '';
                }
            };

            reader.onerror = function() {
                console.error('文件读取错误:', reader.error);
                alert(`文件读取失败: ${reader.error.message}`);
                fileUploadInput.value = '';
            };

            reader.readAsText(file);
        }

        async function saveCurrentData() {
            try {
                // 从后端导出数据
                const exportData = await exportGraphData();
                if (!exportData) {
                    alert('导出数据失败，请检查网络连接');
                    return;
                }

                // 创建输入框用于获取文件路径
                const filePath = prompt('请输入保存路径和文件名（包含.json扩展名）：',
                                      currentFilePath || (() => {
                                          const now = new Date();
                                          const year = now.getFullYear();
                                          const month = String(now.getMonth() + 1).padStart(2, '0');
                                          const day = String(now.getDate()).padStart(2, '0');
                                          const hours = String(now.getHours()).padStart(2, '0');
                                          const minutes = String(now.getMinutes()).padStart(2, '0');
                                          const seconds = String(now.getSeconds()).padStart(2, '0');
                                          const timestamp = `${year}${month}${day}_${hours}${minutes}${seconds}`;
                                          return `kg_${timestamp}.json`;
                                      })());

                if (!filePath) {
                    // 用户取消输入
                    return;
                }

                // 确保文件名以.json结尾
                let fileName = filePath;
                if (!fileName.endsWith('.json')) {
                    fileName += '.json';
                }

                const cleanNodes = exportData.nodes.map(node => ({
                    id: node.id,
                    name: node.name,
                    domain: node.domain || 'default',
                    ...(node.description && node.description.trim() ? { description: node.description } : {})
                }));

                const cleanLinks = exportData.links.map(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;

                    return {
                        source: sourceId,
                        target: targetId,
                        type: link.type,
                        domain: link.domain || 'default'
                    };
                });

                const finalExportData = {
                    nodes: cleanNodes,
                    links: cleanLinks
                };

                const dataStr = JSON.stringify(finalExportData, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);

                const link = document.createElement('a');
                link.href = dataUri;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                // 更新当前文件信息
                currentFilePath = fileName;
                currentFileName.textContent = fileName.split(/[\\/]/).pop();
                currentFileInfo.style.display = 'block';

                console.log('当前数据已保存到文件');
                alert(`数据已成功保存到 ${fileName}`);
            } catch (error) {
                console.error('保存数据失败：', error);
                alert(`保存失败：${error.message}`);
            }
        }

        // ------------------------------
        // 实体管理（新增/修改/删除）
        // ------------------------------

        // 生成默认的实体ID（短数字）
        function generateDefaultEntityId() {
            // 查找最大的数字ID
            let maxId = 0;
            graphData.nodes.forEach(node => {
                const numId = parseInt(node.id, 10);
                if (!isNaN(numId) && numId > maxId) {
                    maxId = numId;
                }
            });
            // 返回下一个数字ID
            return (maxId + 1).toString();
        }

        // 生成默认的实体名称
        function generateDefaultEntityName() {
            const baseNames = ['实体', '概念', '对象', '元素', '节点'];
            const randomName = baseNames[Math.floor(Math.random() * baseNames.length)];
            return `${randomName}${graphData.nodes.length + 1}`;
        }

        // 生成默认的实体描述
        function generateDefaultEntityDescription() {
            const descriptions = [
                '这是一个新实体',
                '该实体的基本描述',
                '相关概念的说明',
                '新创建的实体信息',
                '待完善的实体描述'
            ];
            return descriptions[Math.floor(Math.random() * descriptions.length)];
        }

        // 填充实体表单的默认值
        function populateDefaultEntityValues() {
            if (editingEntityId === null) { // 只有在添加模式下才填充默认值
                entityIdInput.value = generateDefaultEntityId();
                entityNameInput.value = generateDefaultEntityName();
                entityDescInput.value = generateDefaultEntityDescription();
            }
        }

        function updateEntityDropdowns() {
            // 按添加时间排序，最近添加的在前面
            const sortedEntities = [...graphData.nodes].reverse();

            // 更新源实体下拉框
            updateEntityDropdown(sourceEntityDropdown, sortedEntities);
            // 更新目标实体下拉框
            updateEntityDropdown(targetEntityDropdown, sortedEntities);
        }

        function updateEntityDropdown(dropdownElement, entities) {
            dropdownElement.innerHTML = '';

            if (entities.length === 0) {
                const emptyItem = document.createElement('div');
                emptyItem.className = 'dropdown-item';
                emptyItem.textContent = '暂无实体';
                emptyItem.style.cursor = 'default';
                emptyItem.style.opacity = '0.7';
                dropdownElement.appendChild(emptyItem);
                return;
            }

            entities.forEach(entity => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                item.textContent = `${entity.name} (ID: ${entity.id})`;
                item.dataset.id = entity.id;
                item.dataset.name = entity.name;

                item.addEventListener('click', () => {
                    // 根据下拉框类型更新对应输入框
                    if (dropdownElement.id === 'source-entity-dropdown') {
                        sourceEntityInput.value = entity.id;
                        sourceEntityDisplay.value = entity.name;
                        sourceEntityDropdown.classList.remove('visible');
                    } else if (dropdownElement.id === 'target-entity-dropdown') {
                        targetEntityInput.value = entity.id;
                        targetEntityDisplay.value = entity.name;
                        targetEntityDropdown.classList.remove('visible');
                    } else if (dropdownElement.id === 'edit-source-entity-dropdown') {
                        document.getElementById('edit-source-entity').value = entity.id;
                        document.getElementById('edit-source-entity-display').value = entity.name;
                        dropdownElement.classList.remove('visible');
                    } else if (dropdownElement.id === 'edit-target-entity-dropdown') {
                        document.getElementById('edit-target-entity').value = entity.id;
                        document.getElementById('edit-target-entity-display').value = entity.name;
                        dropdownElement.classList.remove('visible');
                    }
                });

                dropdownElement.appendChild(item);
            });
        }

        function filterEntities(keyword) {
            if (!keyword) {
                // 如果没有搜索词，返回按添加时间排序的实体
                return [...graphData.nodes].reverse();
            }

            const lowerKeyword = keyword.toLowerCase();
            return graphData.nodes.filter(entity =>
                entity.name.toLowerCase().includes(lowerKeyword) ||
                entity.id.toLowerCase().includes(lowerKeyword) ||
                (entity.description && entity.description.toLowerCase().includes(lowerKeyword))
            );
        }

        function renderEntityList() {
            if (graphData.nodes.length === 0) {
                entitiesContainer.innerHTML = '<div class="no-data">暂无实体数据</div>';
                return;
            }

            entitiesContainer.innerHTML = '';
            graphData.nodes.forEach(node => {
                const entityItem = document.createElement('div');
                entityItem.className = 'entity-item';
                entityItem.innerHTML = `
                    <div class="entity-info">
                        <strong>${node.name}</strong>
                        <span class="entity-domain">[${node.domain || 'default'}]</span>
                        <p>${node.description?.substring(0, 50) || ''}${node.description && node.description.length > 50 ? '...' : ''}</p>
                    </div>
                    <div class="entity-actions">
                        <div class="action-btn edit-btn" title="编辑" data-id="${node.id}">✏️</div>
                        <div class="action-btn copy-btn" title="复制" data-id="${node.id}">📋</div>
                        <div class="action-btn delete-btn" title="删除" data-id="${node.id}">🗑️</div>
                    </div>
                `;
                // 添加实体按钮事件
                entityItem.querySelector('.edit-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    startEditEntity(node.id);
                });
                // 复制按钮事件
                entityItem.querySelector('.copy-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    copyEntityWithRelation(node.id);
                });
                // 删除实体按钮事件
                entityItem.querySelector('.delete-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteEntity(node.id);
                });
                entityItem.addEventListener('click', () => {
                    showEntityDetail(node);
                    centerNodeInView(node.id);
                    resetSearchState();
                    // 高亮选中的实体
                    clearAllHighlights();
                    nodeGroups.filter(d => d.id === node.id).classed('highlighted', true);
                });
                entitiesContainer.appendChild(entityItem);
            });
        }

        function startEditEntity(id) {
            const entity = graphData.nodes.find(n => n.id === id);
            if (!entity) return;

            editingEntityId = id;
            
            // 重新显示实体详情，这次会包含编辑表单
            showEntityDetail(entity);
        }



        function cancelEdit() {
            editingEntityId = null;
            editingLinkIndex = -1;
            entityFormTitle.textContent = '添加实体'; // 重置为默认标题
            entityIdInput.disabled = false;
            clearEntityForm();
            // 重新填充默认值
            populateDefaultEntityValues();

            addEntityBtn.style.display = 'block';
            updateEntityBtn.style.display = 'none';
            cancelEditBtn.style.display = 'none';
            
            // 如果当前有选中的实体，重新显示其详情（非编辑状态）
            if (selectedNode) {
                showEntityDetail(selectedNode);
            }
        }

        function clearEntityForm() {
            entityIdInput.value = '';
            entityNameInput.value = '';
            entityDescInput.value = '';
            entityDomainSelect.value = 'default';
            customDomainInput.value = '';
            customDomainInput.style.display = 'none';
        }

        // 居中展示实体
        function centerOnEntity(entityId) {
            const node = graphData.nodes.find(n => n.id === entityId);
            if (node && simulation) {
                // 找到对应的D3节点
                const d3Node = d3.selectAll('.node').filter(d => d.id === entityId);
                if (!d3Node.empty()) {
                    // 获取节点位置
                    const nodeData = d3Node.datum();
                    if (nodeData.x !== undefined && nodeData.y !== undefined) {
                        // 居中到该节点
                        const container = document.getElementById('graph-container');
                        const width = container.clientWidth;
                        const height = container.clientHeight;
                        
                        // 计算居中位置
                        const centerX = width / 2 - nodeData.x;
                        const centerY = height / 2 - nodeData.y;
                        
                        // 应用变换
                        svg.select('g').transition()
                            .duration(1000)
                            .attr('transform', `translate(${centerX}, ${centerY})`);
                    }
                }
            }
        }

        // 居中展示关系
        function centerOnRelation(sourceId, targetId, type) {
            const link = graphData.links.find(l => {
                const lSourceId = typeof l.source === 'object' ? l.source.id : l.source;
                const lTargetId = typeof l.target === 'object' ? l.target.id : l.target;
                return lSourceId === sourceId && lTargetId === targetId && l.type === type;
            });
            
            if (link && simulation) {
                // 找到对应的D3关系
                const d3Link = d3.selectAll('.link').filter(d => {
                    const dSourceId = typeof d.source === 'object' ? d.source.id : d.source;
                    const dTargetId = typeof d.target === 'object' ? d.target.id : d.target;
                    return dSourceId === sourceId && dTargetId === targetId && d.type === type;
                });
                
                if (!d3Link.empty()) {
                    const linkData = d3Link.datum();
                    const sourceNode = typeof linkData.source === 'object' ? linkData.source : graphData.nodes.find(n => n.id === linkData.source);
                    const targetNode = typeof linkData.target === 'object' ? linkData.target : graphData.nodes.find(n => n.id === linkData.target);
                    
                    if (sourceNode && targetNode) {
                        // 计算关系的中心点
                        const centerX = (sourceNode.x + targetNode.x) / 2;
                        const centerY = (sourceNode.y + targetNode.y) / 2;
                        
                        // 居中到关系中心
                        const container = document.getElementById('graph-container');
                        const width = container.clientWidth;
                        const height = container.clientHeight;
                        
                        const centerOffsetX = width / 2 - centerX;
                        const centerOffsetY = height / 2 - centerY;
                        
                        svg.select('g').transition()
                            .duration(1000)
                            .attr('transform', `translate(${centerOffsetX}, ${centerOffsetY})`);
                    }
                }
            }
        }

        // 居中展示位置（用于删除操作）
        function centerOnPosition(x, y) {
            if (simulation) {
                const container = document.getElementById('graph-container');
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                const centerOffsetX = width / 2 - x;
                const centerOffsetY = height / 2 - y;
                
                svg.select('g').transition()
                    .duration(1000)
                    .attr('transform', `translate(${centerOffsetX}, ${centerOffsetY})`);
            }
        }

        // 局部更新图表数据而不重新加载
        function updateGraphDataLocally() {
            // 更新数据存储
            allGraphData = { ...graphData };
            filteredGraphData = { ...graphData };
            
            // 更新界面元素
            updateEntityDropdowns();
            renderEntityList();
            updateUsedRelationTypes();
            updateRelationTypeDropdown();
            updateDomainInfo();
            updateDomainDropdown();
            
            // 重新渲染图表（保持当前视图）
            reloadGraph();
        }

        async function addEntity() {
            const id = entityIdInput.value.trim();
            const name = entityNameInput.value.trim();
            const description = entityDescInput.value.trim();
            
            // 获取领域信息
            let domain = entityDomainSelect.value;
            if (domain === 'custom') {
                domain = customDomainInput.value.trim();
                if (!domain) {
                    alert('请输入自定义领域名称');
                    return;
                }
            }

            if (!id || !name) {
                alert('实体ID和名称不能为空');
                return;
            }

            if (graphData.nodes.some(node => node.id === id)) {
                alert('实体ID已存在');
                // 自动生成新的ID
                entityIdInput.value = generateDefaultEntityId();
                return;
            }

            const newEntity = { id, name, domain };
            if (description) newEntity.description = description;

            // 调用后端API创建实体
            const success = await createEntity(newEntity);
            if (success) {
                // 将新实体添加到本地数据中
                graphData.nodes.push(newEntity);
                
                // 局部更新数据
                updateGraphDataLocally();
                
                // 清空表单并填充新的默认值
                clearEntityForm();
                populateDefaultEntityValues();
                
                // 延迟一下等待图表重新渲染完成后居中展示新实体
                setTimeout(() => {
                    centerOnEntity(newEntity.id);
                }, 100);
                
                alert('实体添加成功');
            } else {
                alert('实体添加失败，请检查网络连接');
            }
        }

        async function updateEntity() {
            if (!editingEntityId) return;

            const entity = graphData.nodes.find(n => n.id === editingEntityId);
            if (!entity) {
                alert('实体不存在');
                cancelEdit();
                return;
            }

            const name = entityNameInput.value.trim();
            const description = entityDescInput.value.trim();
            
            // 获取领域信息
            let domain = entityDomainSelect.value;
            if (domain === 'custom') {
                domain = customDomainInput.value.trim();
                if (!domain) {
                    alert('请输入自定义领域名称');
                    return;
                }
            }

            if (!name) {
                alert('实体名称不能为空');
                return;
            }

            const updateData = { name, domain };
            if (description) {
                updateData.description = description;
            }

            // 调用后端API更新实体
            const success = await updateEntityAPI(editingEntityId, updateData);
            if (success) {
                // 更新本地数据
                Object.assign(entity, updateData);
                
                // 局部更新数据
                updateGraphDataLocally();
                
                // 延迟一下等待图表重新渲染完成后居中展示更新后的实体
                setTimeout(() => {
                    centerOnEntity(editingEntityId);
                }, 100);
                
                alert('实体更新成功');

                if (selectedNode && selectedNode.id === editingEntityId) {
                    showEntityDetail(graphData.nodes.find(n => n.id === editingEntityId));
                }

                cancelEdit();
            } else {
                alert('实体更新失败，请检查网络连接');
            }
        }

        // 复制实体功能
        async function copyEntity(sourceId) {
            const sourceEntity = graphData.nodes.find(n => n.id === sourceId);
            if (!sourceEntity) return;

            // 生成新的唯一ID（基于原ID规则，确保不重复）
            const newId = generateUniqueEntityId(sourceEntity.id);
            // 生成新的实体名称（添加"副本"后缀）
            const newName = `${sourceEntity.name}（副本）`;

            // 创建复制的实体对象
            const copiedEntity = {
                id: newId,
                name: newName,
                domain: sourceEntity.domain || 'default',
                ...(sourceEntity.description ? { description: sourceEntity.description } : {})
            };

            // 调用后端API创建复制的实体
            const success = await createEntity(copiedEntity);
            if (success) {
                // 将新实体添加到本地数据中
                graphData.nodes.push(copiedEntity);
                
                // 局部更新数据
                updateGraphDataLocally();

                // 显示新复制实体的详情页（不进入编辑模式）
                // 确保不设置编辑状态
                editingEntityId = null;
                showEntityDetail(copiedEntity);

                // 等待D3.js simulation稳定后居中放大展示原实体（源实体）
                const waitForSimulation = () => {
                    if (simulation && simulation.alpha() > 0.01) {
                        // simulation还在运行，继续等待
                        setTimeout(waitForSimulation, 50);
                    } else {
                        // simulation已稳定，执行居中放大
                        setTimeout(() => {
                            // 清除所有高亮
                            clearAllHighlights();
                            
                            // 高亮原实体
                            const sourceNodeGroup = d3.selectAll('.node').filter(d => d.id === sourceId);
                            if (!sourceNodeGroup.empty()) {
                                sourceNodeGroup.classed('highlighted', true);
                            }
                            
                            // 居中放大显示
                            centerNodeInView(sourceId);
                        }, 100);
                    }
                };
                waitForSimulation();

                alert(`实体复制成功！新实体ID：${newId}`);
            } else {
                alert('实体复制失败，请检查网络连接');
            }
        }

        // 生成不重复的实体ID
        function generateUniqueEntityId(originalId) {
            // 尝试在原ID后添加数字后缀（如原ID为"1"，尝试"1_1"、"1_2"...）
            let suffix = 1;
            let newId = `${originalId}_${suffix}`;
            while (graphData.nodes.some(node => node.id === newId)) {
                suffix++;
                newId = `${originalId}_${suffix}`;
            }
            return newId;
        }

        // 复制后自动进入编辑模式（已废弃，改为显示详情页）
        function startEditCopiedEntity(entity) {
            // 这个函数现在不再使用，改为直接显示详情页
            showEntityDetail(entity);
        }

        // 复制实体并建立关系功能
        async function copyEntityWithRelation(sourceId) {
            const sourceEntity = graphData.nodes.find(n => n.id === sourceId);
            if (!sourceEntity) {
                alert('源实体不存在');
                return;
            }

            // 生成新的唯一ID
            const newId = generateUniqueEntityId(sourceEntity.id);
            // 生成新的实体名称（添加"副本"后缀）
            const newName = `${sourceEntity.name}（副本）`;

            // 创建复制的实体对象
            const copiedEntity = {
                id: newId,
                name: newName,
                domain: sourceEntity.domain || 'default',
                ...(sourceEntity.description ? { description: sourceEntity.description } : {})
            };

            try {
                // 1. 调用后端API创建复制的实体
                const entitySuccess = await createEntity(copiedEntity);
                if (!entitySuccess) {
                    alert('实体复制失败，请检查网络连接');
                    return;
                }

                // 2. 创建从复制实体指向原实体的关系
                const relationData = {
                    source: newId,
                    target: sourceId,
                    type: '复制自',
                    description: `从实体"${sourceEntity.name}"复制而来`,
                    domain: sourceEntity.domain || 'default'
                };

                const relationResult = await createRelationship(relationData);
                if (!relationResult) {
                    alert('实体复制成功，但关系创建失败');
                    // 即使关系创建失败，实体已经创建成功，所以继续
                }

                // 3. 更新本地数据
                graphData.nodes.push(copiedEntity);
                
                if (relationResult && relationResult.data && relationResult.data.id) {
                    // 添加关系到本地数据，包含从后端返回的关系ID
                    const newRelation = {
                        id: relationResult.data.id, // 从后端响应的data.id中获取关系ID
                        source: newId,
                        target: sourceId,
                        type: '复制自',
                        description: relationData.description,
                        domain: relationData.domain
                    };
                    graphData.links.push(newRelation);
                }

                // 4. 局部更新数据
                updateGraphDataLocally();

                // 5. 显示新复制实体的详情页（不进入编辑模式）
                // 确保不设置编辑状态
                editingEntityId = null;
                showEntityDetail(copiedEntity);

                // 6. 等待D3.js simulation稳定后居中放大展示原实体（源实体）
                const waitForSimulation = () => {
                    if (simulation && simulation.alpha() > 0.01) {
                        // simulation还在运行，继续等待
                        setTimeout(waitForSimulation, 50);
                    } else {
                        // simulation已稳定，执行居中放大
                        setTimeout(() => {
                            // 清除所有高亮
                            clearAllHighlights();
                            
                            // 高亮原实体
                            const sourceNodeGroup = d3.selectAll('.node').filter(d => d.id === sourceId);
                            if (!sourceNodeGroup.empty()) {
                                sourceNodeGroup.classed('highlighted', true);
                            }
                            
                            // 居中放大显示
                            centerNodeInView(sourceId);
                        }, 100);
                    }
                };
                waitForSimulation();

                const successMsg = relationResult 
                    ? `实体复制成功！新实体ID：${newId}，已建立与原实体的关系`
                    : `实体复制成功！新实体ID：${newId}`;
                alert(successMsg);

            } catch (error) {
                console.error('复制实体时发生错误:', error);
                alert('复制实体时发生错误，请重试');
            }
        }

        async function deleteEntity(id) {
            if (!confirm('确定要删除此实体吗？关联的关系也将被删除')) return;

            // 获取要删除的实体及其关系信息
            const entityToDelete = graphData.nodes.find(node => node.id === id);
            if (!entityToDelete) {
                alert('实体不存在');
                return;
            }

            // 查找与被删除实体相关的所有关系
            const relatedLinks = graphData.links.filter(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                return sourceId === id || targetId === id;
            });

            // 获取与被删除实体有关系的其他实体ID
            const relatedEntityIds = new Set();
            relatedLinks.forEach(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                if (sourceId !== id) relatedEntityIds.add(sourceId);
                if (targetId !== id) relatedEntityIds.add(targetId);
            });

            const relatedEntities = Array.from(relatedEntityIds);

            // 调用后端API删除实体
            const success = await deleteEntityAPI(id);
            if (success) {
                // 从本地数据中删除实体
                graphData.nodes = graphData.nodes.filter(node => node.id !== id);
                
                // 删除相关的所有关系
                graphData.links = graphData.links.filter(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    return sourceId !== id && targetId !== id;
                });
                
                // 局部更新数据
                updateGraphDataLocally();

                // 如果删除的实体是当前选中的源实体或目标实体，则清空
                if (sourceEntityInput.value === id) {
                    sourceEntityInput.value = '';
                    sourceEntityDisplay.value = '';
                }
                if (targetEntityInput.value === id) {
                    targetEntityInput.value = '';
                    targetEntityDisplay.value = '';
                }

                if (selectedNode && selectedNode.id === id) {
                    selectedNode = null;
                    detailView.innerHTML = '<div class="no-data">选择一个实体或关系查看详情</div>';
                }

                resetSearchState();

                // 根据关系数量决定删除后的显示逻辑
                if (relatedEntities.length === 0) {
                    // 无任何关系：适配显示
                    setTimeout(() => {
                        // 重置视图到默认状态
                        if (svg && zoom) {
                            const container = document.getElementById('graph-container');
                            const containerWidth = container.clientWidth;
                            const containerHeight = container.clientHeight;
                            
                            svg.transition()
                                .duration(800)
                                .ease(d3.easeCubic)
                                .call(zoom.transform,
                                    d3.zoomIdentity
                                        .translate(containerWidth / 2, containerHeight / 2)
                                        .scale(1.0)
                                );
                        }
                    }, 300);
                } else if (relatedEntities.length === 1) {
                    // 只与一个实体有关系：居中显示该实体
                    const relatedEntityId = relatedEntities[0];
                    setTimeout(() => {
                        // 清除所有高亮
                        clearAllHighlights();
                        
                        // 高亮相关实体
                        const relatedNodeGroup = d3.selectAll('.node').filter(d => d.id === relatedEntityId);
                        if (!relatedNodeGroup.empty()) {
                            relatedNodeGroup.classed('highlighted', true);
                        }
                        
                        // 居中放大显示相关实体
                        centerNodeInView(relatedEntityId);
                    }, 300);
                } else {
                    // 与多个实体有关系：居中显示任意其中一个实体
                    const randomRelatedEntityId = relatedEntities[Math.floor(Math.random() * relatedEntities.length)];
                    setTimeout(() => {
                        // 清除所有高亮
                        clearAllHighlights();
                        
                        // 高亮选中的相关实体
                        const relatedNodeGroup = d3.selectAll('.node').filter(d => d.id === randomRelatedEntityId);
                        if (!relatedNodeGroup.empty()) {
                            relatedNodeGroup.classed('highlighted', true);
                        }
                        
                        // 居中放大显示选中的相关实体
                        centerNodeInView(randomRelatedEntityId);
                    }, 300);
                }

                alert('实体删除成功');
            } else {
                alert('实体删除失败，请检查网络连接');
            }
        }

        // ------------------------------
        // 关系管理（添加/修改/删除）
        // ------------------------------
        async function addRelation() {
            const sourceId = sourceEntityInput.value;
            const targetId = targetEntityInput.value;
            const type = relationTypeInput.value.trim();

            if (!sourceId || !targetId || !type) {
                alert('请完善关系信息');
                return;
            }

            if (sourceId === targetId) {
                alert('源实体和目标实体不能相同');
                return;
            }

            const relationExists = graphData.links.some(link => {
                const linkSourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const linkTargetId = typeof link.target === 'object' ? link.target.id : link.target;
                return linkSourceId === sourceId && linkTargetId === targetId && link.type === type;
            });

            if (relationExists) {
                alert('此关系已存在');
                return;
            }

            // 获取源实体的领域信息
            const sourceEntity = graphData.nodes.find(n => n.id === sourceId);
            const targetEntity = graphData.nodes.find(n => n.id === targetId);
            const domain = sourceEntity?.domain || targetEntity?.domain || 'default';

            // 调用后端API创建关系
            const result = await createRelationship({
                source: sourceId,
                target: targetId,
                type: type,
                domain: domain
            });

            if (result && result.data && result.data.id) {
                // 将新关系添加到本地数据中，包含关系ID
                const newLink = {
                    id: result.data.id, // 从后端响应的data.id中获取关系ID
                    source: sourceId,
                    target: targetId,
                    type: type,
                    domain: domain
                };
                graphData.links.push(newLink);
                
                // 局部更新数据
                updateGraphDataLocally();
                
                clearRelationForm();

                if (selectedNode && (selectedNode.id === sourceId || selectedNode.id === targetId)) {
                    showEntityDetail(selectedNode);
                }

                resetSearchState();

                // 延迟一下等待图表重新渲染完成后居中展示新关系
                setTimeout(() => {
                    centerOnRelation(sourceId, targetId, type);
                }, 100);

                alert('关系添加成功');
            } else {
                alert('关系添加失败，请检查网络连接');
            }
        }

        // 开始编辑关系
        function startEditRelation(linkIndex) {
            if (linkIndex < 0 || linkIndex >= graphData.links.length) return;

            const link = graphData.links[linkIndex];
            editingLinkIndex = linkIndex;

            // 获取源实体和目标实体的ID（处理对象引用的情况）
            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;

            // 填充表单
            sourceEntityInput.value = sourceId;
            const sourceEntity = graphData.nodes.find(n => n.id === sourceId);
            sourceEntityDisplay.value = sourceEntity ? sourceEntity.name : '';

            targetEntityInput.value = targetId;
            const targetEntity = graphData.nodes.find(n => n.id === targetId);
            targetEntityDisplay.value = targetEntity ? targetEntity.name : '';

            relationTypeInput.value = link.type;
            relationTypeDisplay.value = link.type;

            // 显示关系详情视图
            showRelationDetail(link);
        }

        // 更新关系
        function updateRelation() {
            if (editingLinkIndex < 0 || editingLinkIndex >= graphData.links.length) return;

            const originalLink = graphData.links[editingLinkIndex];
            const originalSourceId = typeof originalLink.source === 'object' ? originalLink.source.id : originalLink.source;
            const originalTargetId = typeof originalLink.target === 'object' ? originalLink.target.id : originalLink.target;

            const newSourceId = sourceEntityInput.value;
            const newTargetId = targetEntityInput.value;
            const newType = relationTypeInput.value.trim();

            if (!newSourceId || !newTargetId || !newType) {
                alert('请完善关系信息');
                return;
            }

            if (newSourceId === newTargetId) {
                alert('源实体和目标实体不能相同');
                return;
            }

            // 检查更新后的关系是否已存在（排除自身）
            const relationExists = graphData.links.some((link, index) => {
                if (index === editingLinkIndex) return false; // 跳过自身

                const linkSourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const linkTargetId = typeof link.target === 'object' ? link.target.id : link.target;
                return linkSourceId === newSourceId && linkTargetId === newTargetId && link.type === newType;
            });

            if (relationExists) {
                alert('此关系已存在');
                return;
            }

            // 记录旧的关系类型，用于更新关系类型集合
            const oldType = originalLink.type;

            // 更新关系数据
            graphData.links[editingLinkIndex] = {
                source: newSourceId,
                target: newTargetId,
                type: newType
            };

            // 更新已使用的关系类型
            updateUsedRelationTypes();
            updateRelationTypeDropdown();

            // 刷新界面
            reloadGraph();
            clearRelationForm();
            editingLinkIndex = -1;

            // 更新详情视图
            showRelationDetail(graphData.links[editingLinkIndex]);

            alert('关系更新成功');
        }

        function clearRelationForm() {
            sourceEntityInput.value = '';
            sourceEntityDisplay.value = '';
            targetEntityInput.value = '';
            targetEntityDisplay.value = '';
            relationTypeInput.value = '';
            relationTypeDisplay.value = '';
        }

        async function deleteRelation(sourceId, targetId, type) {
            if (!confirm(`确定要删除关系「${type}」吗？`)) return;

            const source = typeof sourceId === 'object' ? sourceId.id : sourceId;
            const target = typeof targetId === 'object' ? targetId.id : targetId;

            // 找到要删除的关系
            const linkToDelete = graphData.links.find(link => {
                const linkSource = typeof link.source === 'object' ? link.source.id : link.source;
                const linkTarget = typeof link.target === 'object' ? link.target.id : link.target;
                return linkSource === source && linkTarget === target && link.type === type;
            });

            if (!linkToDelete) {
                alert('未找到该关系');
                return;
            }

            // 记录要删除的关系的位置
            let deletePosition = null;
            if (simulation) {
                const sourceNode = graphData.nodes.find(n => n.id === source);
                const targetNode = graphData.nodes.find(n => n.id === target);
                if (sourceNode && targetNode) {
                    // 计算关系的中心点
                    deletePosition = {
                        x: (sourceNode.x + targetNode.x) / 2,
                        y: (sourceNode.y + targetNode.y) / 2
                    };
                }
            }

            // 获取关系ID
            const relationshipId = linkToDelete.id;
            
            console.log('要删除的关系:', linkToDelete);
            console.log('关系ID:', relationshipId);
            
            if (!relationshipId) {
                alert('关系ID不存在，无法删除');
                return;
            }

            // 调用后端API删除关系
            const success = await deleteRelationshipAPI(relationshipId);
            if (success) {
                // 从本地数据中删除关系
                graphData.links = graphData.links.filter(link => {
                    const linkSource = typeof link.source === 'object' ? link.source.id : link.source;
                    const linkTarget = typeof link.target === 'object' ? link.target.id : link.target;
                    return !(linkSource === source && linkTarget === target && link.type === type);
                });
                
                // 局部更新数据
                updateGraphDataLocally();

                if (selectedNode && (selectedNode.id === source || selectedNode.id === target)) {
                    showEntityDetail(selectedNode);
                }

                if (selectedLink &&
                    (typeof selectedLink.source === 'object' ? selectedLink.source.id : selectedLink.source) === source &&
                    (typeof selectedLink.target === 'object' ? selectedLink.target.id : selectedLink.target) === target &&
                    selectedLink.type === type) {
                    selectedLink = null;
                    detailView.innerHTML = '<div class="no-data">选择一个实体或关系查看详情</div>';
                }

                resetSearchState();

                // 延迟一下等待图表重新渲染完成后居中到删除位置
                if (deletePosition) {
                    setTimeout(() => {
                        centerOnPosition(deletePosition.x, deletePosition.y);
                    }, 100);
                }

                alert('关系删除成功');
            } else {
                alert('关系删除失败，请检查网络连接');
            }
        }

        // ------------------------------
        // 图谱可视化与交互
        // ------------------------------
        function initializeGraph() {
            const container = document.getElementById('graph-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            d3.select('#graph-container').select('svg').remove();

            svg = d3.select('#graph-container')
                .append('svg')
                .attr('width', '100%')
                .attr('height', '100%')
                .attr('viewBox', [0, 0, width, height])
                .on('click', handleSvgClick); // 添加空白处点击事件

            // 定义箭头标记，为每个箭头添加唯一ID
            const defs = svg.append('defs');
            graphData.links.forEach((link, index) => {
                defs.append('marker')
                    .attr('id', `arrow-${index}`)
                .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 45) // 箭头位置调整，适应大节点
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5Z') // 添加Z闭合路径
                    .attr('class', 'arrowhead')
                    .attr('fill', 'none') // 设置为空心
                    .attr('stroke', '#666') // 设置边框颜色
                    .attr('stroke-width', 1.5) // 设置边框宽度
                    .attr('data-link-index', index)
                    .on('click', function(event) {
                        event.stopPropagation();
                        const linkIndex = parseInt(d3.select(this).attr('data-link-index'));
                        const link = graphData.links[linkIndex];
                        if (link) {
                            selectedLink = link;
                            clearAllHighlights();
                            highlightRelationAndEntities(link);
                            showRelationDetail(link);
                            centerRelationInView(link);
                            resetSearchState();
                        }
                    });
            });

            zoom = d3.zoom()
                .scaleExtent([0.1, 5])
                .on('zoom', (event) => {
                    transform = event.transform;
                    g.attr('transform', transform);
                });

            svg.call(zoom);

            const g = svg.append('g');

            // 调整力导向参数，适应大节点
            simulation = d3.forceSimulation(graphData.nodes)
                .force('link', d3.forceLink(graphData.links).id(d => d.id).distance(200)) // 增加节点间距
                .force('charge', d3.forceManyBody().strength(-600)) // 增加排斥力
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(70)); // 增加碰撞检测半径

            // 绘制连线并添加箭头，为每条线分配对应的箭头ID
            linkElements = g.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(graphData.links)
                .enter()
                .append('line')
                .attr('class', 'link')
                .attr('stroke-width', 2)
                .attr('data-link-index', (d, i) => i)
                .attr('marker-end', (d, i) => `url(#arrow-${i})`) // 为每条线分配对应的箭头
                .on('click', (event, d) => {
                    // 点击关系边显示详情
                    event.stopPropagation();
                    selectedLink = d;
                    clearAllHighlights();

                    // 高亮当前关系及相关实体和箭头
                    highlightRelationAndEntities(d);

                    showRelationDetail(d);
                    centerRelationInView(d);
                    resetSearchState();
                });

            // 绘制连线标签
            linkLabelElements = g.append('g')
                .attr('class', 'link-labels')
                .selectAll('text')
                .data(graphData.links)
                .enter()
                .append('text')
                .attr('class', 'link-label')
                .attr('data-link-index', (d, i) => i)
                .text(d => d.type)
                .on('click', (event, d) => {
                    // 点击关系标签显示详情
                    event.stopPropagation();
                    selectedLink = d;
                    clearAllHighlights();

                    // 高亮当前关系及相关实体和箭头
                    highlightRelationAndEntities(d);

                    showRelationDetail(d);
                    centerRelationInView(d);
                    resetSearchState();
                });

            // 绘制节点
            nodeGroups = g.append('g')
                .attr('class', 'nodes')
                .selectAll('g')
                .data(graphData.nodes)
                .enter()
                .append('g')
                .attr('data-id', d => d.id)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // 大实心圆节点
            nodeGroups.append('circle')
                .attr('r', 25) // 大节点半径
                .attr('fill', '#66bb6a');

            // 节点内部文字（居中显示）
            nodeGroups.append('text')
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .text(d => {
                    // 长名称自动截断显示
                    if (d.name.length > 5) {
                        return d.name.substring(0, 5) + '...';
                    }
                    return d.name;
                })
                .attr('fill', '#ffffff'); // 白色文字，与节点形成对比

            nodeGroups.on('click', (event, d) => {
                event.stopPropagation(); // 阻止事件冒泡到SVG
                selectedNode = d;
                selectedLink = null;
                clearAllHighlights();
                d3.select(event.currentTarget).classed('highlighted', true);
                showEntityDetail(d);
                centerNodeInView(d.id);
                resetSearchState();
            });

            // 新增：鼠标事件绑定（悬浮显示/隐藏信息）
            // 节点组的鼠标事件绑定（替换原有代码）
            nodeGroups
                .on('mouseover', function(event, d) {
                    const tooltip = document.getElementById('entity-tooltip');
                    const titleEl = document.getElementById('tooltip-title');
                    const idEl = document.getElementById('tooltip-id');
                    const domainEl = document.getElementById('tooltip-domain');
                    const descEl = document.getElementById('tooltip-desc');

                    // 1. 填充实体信息
                    titleEl.textContent = d.name;
                    idEl.textContent = d.id;
                    domainEl.textContent = d.domain || 'default';
                    descEl.textContent = d.description || '无';

                    // 2. 获取可视化面板的DOM元素及位置信息
                    const visualizationPanel = document.querySelector('.visualization-panel');
                    const panelRect = visualizationPanel.getBoundingClientRect(); // 面板在页面中的位置

                    // 3. 计算面板中心点坐标（相对于页面左上角）
                    const centerX = panelRect.left + panelRect.width / 2;
                    const centerY = panelRect.top + panelRect.height / 2;

                    // 4. 设置tooltip位置（基于页面坐标）
                    tooltip.style.left = `${centerX}px`;
                    tooltip.style.top = `${centerY}px`;
                    tooltip.classList.add('visible');
                })
                .on('mousemove', function(event, d) {
                    // 鼠标移动时保持居中（与mouseover逻辑一致）
                    const tooltip = document.getElementById('entity-tooltip');
                    const visualizationPanel = document.querySelector('.visualization-panel');
                    const panelRect = visualizationPanel.getBoundingClientRect();

                    const centerX = panelRect.left + panelRect.width / 2;
                    const centerY = panelRect.top + panelRect.height / 2;

                    tooltip.style.left = `${centerX}px`;
                    tooltip.style.top = `${centerY}px`;
                })
                .on('mouseout', function() {
                    const tooltip = document.getElementById('entity-tooltip');
                    tooltip.classList.remove('visible');
                });

            // 存储箭头元素引用，添加数据属性标识对应的关系索引
            arrowElements = svg.selectAll('.arrowhead');

            simulation.on('tick', () => {
                // 计算双向边的偏移
                const linkOffsets = calculateLinkOffsets();
                
                linkElements
                    .attr('x1', (d, i) => d.source.x + (linkOffsets[i] ? linkOffsets[i].x1 : 0))
                    .attr('y1', (d, i) => d.source.y + (linkOffsets[i] ? linkOffsets[i].y1 : 0))
                    .attr('x2', (d, i) => d.target.x + (linkOffsets[i] ? linkOffsets[i].x2 : 0))
                    .attr('y2', (d, i) => d.target.y + (linkOffsets[i] ? linkOffsets[i].y2 : 0));

                linkLabelElements
                    .attr('x', (d, i) => {
                        const offset = linkOffsets[i];
                        if (offset) {
                            return (d.source.x + d.target.x) / 2 + offset.labelX;
                        }
                        return (d.source.x + d.target.x) / 2;
                    })
                    .attr('y', (d, i) => {
                        const offset = linkOffsets[i];
                        if (offset) {
                            return (d.source.y + d.target.y) / 2 + offset.labelY;
                        }
                        return (d.source.y + d.target.y) / 2;
                    });

                nodeGroups.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            console.log('图谱初始化完成，节点数：', graphData.nodes.length);
        }

        // 计算双向边的偏移量
        function calculateLinkOffsets() {
            const offsets = new Array(graphData.links.length).fill(null);
            const offsetDistance = 8; // 平行边的间距
            
            // 遍历所有连线，找出双向边
            for (let i = 0; i < graphData.links.length; i++) {
                const link1 = graphData.links[i];
                const source1 = typeof link1.source === 'object' ? link1.source.id : link1.source;
                const target1 = typeof link1.target === 'object' ? link1.target.id : link1.target;
                
                // 检查是否有反向的边
                for (let j = i + 1; j < graphData.links.length; j++) {
                    const link2 = graphData.links[j];
                    const source2 = typeof link2.source === 'object' ? link2.source.id : link2.source;
                    const target2 = typeof link2.target === 'object' ? link2.target.id : link2.target;
                    
                    // 如果找到双向边
                    if (source1 === target2 && target1 === source2) {
                        // 计算边的方向向量
                        const node1 = graphData.nodes.find(n => n.id === source1);
                        const node2 = graphData.nodes.find(n => n.id === target1);
                        
                        if (node1 && node2) {
                            const dx = node2.x - node1.x;
                            const dy = node2.y - node1.y;
                            const length = Math.sqrt(dx * dx + dy * dy);
                            
                            if (length > 0) {
                                // 计算垂直偏移向量
                                const perpX = -dy / length * offsetDistance;
                                const perpY = dx / length * offsetDistance;
                                
                                // 为第一条边设置偏移
                                offsets[i] = {
                                    x1: perpX,
                                    y1: perpY,
                                    x2: perpX,
                                    y2: perpY,
                                    labelX: perpX,
                                    labelY: perpY
                                };
                                
                                // 为第二条边设置反向偏移
                                offsets[j] = {
                                    x1: -perpX,
                                    y1: -perpY,
                                    x2: -perpX,
                                    y2: -perpY,
                                    labelX: -perpX,
                                    labelY: -perpY
                                };
                            }
                        }
                        break;
                    }
                }
            }
            
            return offsets;
        }

        // 高亮关系及相关实体和箭头
        function highlightRelationAndEntities(link) {
            // 找到当前关系在数组中的索引
            const linkIndex = graphData.links.indexOf(link);
            if (linkIndex === -1) return;

            // 获取源实体和目标实体的ID
            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;

            // 高亮关系线
            linkElements.filter((l, i) => i === linkIndex).classed('link-highlighted', true);

            // 高亮箭头 - 修复的关键部分
            d3.select(`#arrow-${linkIndex}`).select('path').classed('arrow-highlighted', true);

            // 高亮关系标签
            linkLabelElements.filter((l, i) => i === linkIndex).classed('link-label-highlighted', true);

            // 高亮源实体和目标实体
            nodeGroups.filter(d => d.id === sourceId || d.id === targetId)
                .classed('relation-entity-highlighted', true);
        }

        // 处理SVG空白处点击事件
        function handleSvgClick(event) {
            // 只有点击空白处才触发
            if (event.target === svg.node()) {
                clearAllHighlights();
                selectedNode = null;
                selectedLink = null;
                detailView.innerHTML = '<div class="no-data">选择一个实体或关系查看详情</div>';
                resetSearchState();
            }
        }

        // 清除所有高亮效果
        function clearAllHighlights() {
            if (!svg) return;
            // 清除节点高亮和淡化效果
            if (nodeGroups) {
                nodeGroups
                    .classed('highlighted', false)
                    .classed('search-highlighted', false)
                    .classed('relation-entity-highlighted', false)
                    .classed('faded', false);
            }
            // 清除连线高亮和淡化效果
            if (linkElements) {
                linkElements
                    .classed('search-highlighted-link', false)
                    .classed('link-highlighted', false)
                    .classed('faded', false);
            }
            // 清除连线标签高亮和淡化效果
            if (linkLabelElements) {
                linkLabelElements
                    .classed('search-highlighted-link-label', false)
                    .classed('link-label-highlighted', false)
                    .classed('faded', false);
            }
            // 清除箭头高亮和淡化效果
            if (arrowElements) {
                arrowElements
                    .classed('search-highlighted-arrow', false)
                    .classed('arrow-highlighted', false)
                    .classed('faded', false);
            }
        }

        // 节点拖拽交互函数
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function reloadGraph() {
            console.log('重新加载图谱，节点数：', graphData.nodes.length);
            graphData.links.forEach(link => {
                if (typeof link.source !== 'string') link.source = link.source.id;
                if (typeof link.target !== 'string') link.target = link.target.id;
            });
            initializeGraph();
        }


        
        // 获取Cookie的辅助函数
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        
        // 描述框控制功能
        function toggleDescription() {
            const descriptionBox = document.getElementById('entity-description');
            const descriptionText = document.getElementById('description-text');
            const expandBtn = document.querySelector('#entity-description .expand-btn');
            
            if (descriptionBox && descriptionText) {
                const isExpanded = descriptionBox.classList.contains('expanded');
                
                if (isExpanded) {
                    // 收起：截断文本
                    descriptionBox.classList.remove('expanded');
                    expandBtn.textContent = '展开';
                    
                    // 如果文本超过100个字符，截断显示
                    const fullText = descriptionText.getAttribute('data-full-text');
                    if (fullText && fullText.length > 100) {
                        descriptionText.textContent = fullText.substring(0, 100) + '...';
                    }
                } else {
                    // 展开：显示完整文本
                    descriptionBox.classList.add('expanded');
                    expandBtn.textContent = '收起';
                    
                    // 显示完整文本
                    const fullText = descriptionText.getAttribute('data-full-text');
                    if (fullText) {
                        descriptionText.textContent = fullText;
                    }
                }
            }
        }
        
        function copyDescription() {
            const descriptionText = document.getElementById('description-text');
            if (descriptionText) {
                // 始终复制完整内容
                const fullText = descriptionText.getAttribute('data-full-text') || descriptionText.textContent;
                navigator.clipboard.writeText(fullText).then(() => {
                    // 显示复制成功提示
                    const copyBtn = document.querySelector('#entity-description .copy-btn');
                    const originalText = copyBtn.textContent;
                    copyBtn.textContent = '已复制';
                    copyBtn.style.background = '#4caf50';
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                        copyBtn.style.background = '#2196f3';
                    }, 1000);
                }).catch(err => {
                    console.error('复制失败:', err);
                    alert('复制失败，请手动复制');
                });
            }
        }
        
        // 视图控制功能
        function zoomIn() {
            if (!svg || !zoom) return;
            svg.transition().duration(300).call(
                zoom.scaleBy, 1.3
            );
        }

        function zoomOut() {
            if (!svg || !zoom) return;
            svg.transition().duration(300).call(
                zoom.scaleBy, 0.77
            );
        }

        function fitView() {
            if (!svg || !zoom || graphData.nodes.length === 0) return;

            const nodes = graphData.nodes;
            const minX = Math.min(...nodes.map(d => d.x));
            const maxX = Math.max(...nodes.map(d => d.x));
            const minY = Math.min(...nodes.map(d => d.y));
            const maxY = Math.max(...nodes.map(d => d.y));

            const width = maxX - minX;
            const height = maxY - minY;

            const container = document.getElementById('graph-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            const scaleX = containerWidth / (width * 1.1);
            const scaleY = containerHeight / (height * 1.1);
            const scale = Math.min(scaleX, scaleY, 1);

            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;

            svg.transition().duration(700).call(
                zoom.transform,
                d3.zoomIdentity
                    .translate(containerWidth / 2, containerHeight / 2)
                    .scale(scale)
                    .translate(-centerX, -centerY)
            );
        }

        function resetLayout() {
            if (!simulation) return;

            simulation.alpha(0.3).restart();

            if (svg && zoom) {
                svg.transition().duration(300).call(
                    zoom.transform,
                    transform
                );
            }
        }

        function centerNodeInView(nodeId) {
            if (!svg || !zoom) return;

            // 首先尝试从当前graphData中查找节点
            let node = graphData.nodes.find(n => n.id === nodeId);
            
            // 如果没找到，尝试从allGraphData中查找
            if (!node && allGraphData && allGraphData.nodes) {
                node = allGraphData.nodes.find(n => n.id === nodeId);
            }
            
            if (!node) {
                console.warn(`未找到节点: ${nodeId}`);
                return;
            }

            // 如果节点没有位置信息，尝试从D3.js的simulation中获取
            if (node.x === undefined || node.y === undefined) {
                const d3Node = d3.selectAll('.node').filter(d => d.id === nodeId);
                if (!d3Node.empty()) {
                    const nodeData = d3Node.datum();
                    if (nodeData.x !== undefined && nodeData.y !== undefined) {
                        node.x = nodeData.x;
                        node.y = nodeData.y;
                    } else {
                        console.warn(`节点 ${nodeId} 在D3.js中没有位置信息`);
                        return;
                    }
                } else {
                    console.warn(`未找到节点 ${nodeId} 的D3.js元素`);
                    return;
                }
            }

            const container = document.getElementById('graph-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            // 减小缩放比例，使居中放大效果更小
            let scale = 1.0;
            if (graphData.nodes.length > 10) {
                scale = 1.3;
            } else if (graphData.nodes.length <= 3) {
                scale = 0.8;
            }

            scale = Math.min(scale, 3); // 限制最大缩放比例

            svg.transition()
                .duration(800)
                .ease(d3.easeCubic)
                .call(zoom.transform,
                    d3.zoomIdentity
                        .translate(containerWidth / 2, containerHeight / 2)
                        .scale(scale)
                        .translate(-node.x, -node.y)
                );
        }

        // 为搜索到的实体添加黄色高亮，并淡化其他实体和关系
        function highlightSearchEntity(nodeId) {
            clearAllHighlights();

            // 高亮匹配的实体
            nodeGroups.filter(d => d.id === nodeId)
                .classed('search-highlighted', true);

            // 淡化所有其他实体
            nodeGroups.filter(d => d.id !== nodeId)
                .classed('faded', true);

            // 淡化所有关系
            if (linkElements) {
                linkElements.classed('faded', true);
            }
            if (linkLabelElements) {
                linkLabelElements.classed('faded', true);
            }
            if (arrowElements) {
                arrowElements.classed('faded', true);
            }
        }

        // 为搜索到的关系添加黄色高亮，并淡化其他实体和关系
        function highlightSearchRelation(link) {
            clearAllHighlights();

            // 找到当前关系在数组中的索引
            const linkIndex = graphData.links.findIndex(l => {
                const lSourceId = typeof l.source === 'object' ? l.source.id : l.source;
                const lTargetId = typeof l.target === 'object' ? l.target.id : l.target;
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                return lSourceId === sourceId && lTargetId === targetId && l.type === link.type;
            });

            if (linkIndex === -1) return; // 未找到关系，退出

            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            const relationType = link.type;

            // 高亮相关节点
            nodeGroups.filter(d => d.id === sourceId || d.id === targetId)
                .classed('search-highlighted', true);

            // 淡化其他节点
            nodeGroups.filter(d => d.id !== sourceId && d.id !== targetId)
                .classed('faded', true);

            // 高亮匹配的关系连线
            if (linkElements) {
                linkElements.filter(l => {
                    const lSourceId = typeof l.source === 'object' ? l.source.id : l.source;
                    const lTargetId = typeof l.target === 'object' ? l.target.id : l.target;
                    return lSourceId === sourceId && lTargetId === targetId && l.type === relationType;
                }).classed('search-highlighted-link', true)
                  .classed('faded', false);

                // 淡化其他关系
                linkElements.filter(l => {
                    const lSourceId = typeof l.source === 'object' ? l.source.id : l.source;
                    const lTargetId = typeof l.target === 'object' ? l.target.id : l.target;
                    return !(lSourceId === sourceId && lTargetId === targetId && l.type === relationType);
                }).classed('faded', true);
            }

            // 高亮匹配的关系标签
            if (linkLabelElements) {
                linkLabelElements.filter(l => {
                    const lSourceId = typeof l.source === 'object' ? l.source.id : l.source;
                    const lTargetId = typeof l.target === 'object' ? l.target.id : l.target;
                    return lSourceId === sourceId && lTargetId === targetId && l.type === relationType;
                }).classed('search-highlighted-link-label', true)
                  .classed('faded', false);

                // 淡化其他关系标签
                linkLabelElements.filter(l => {
                    const lSourceId = typeof l.source === 'object' ? l.source.id : l.source;
                    const lTargetId = typeof l.target === 'object' ? l.target.id : l.target;
                    return !(lSourceId === sourceId && lTargetId === targetId && l.type === relationType);
                }).classed('faded', true);
            }

            // 高亮匹配关系的箭头
            if (arrowElements) {
                // 找到当前关系对应的箭头并高亮
                arrowElements.filter(`[data-link-index="${linkIndex}"]`)
                    .classed('search-highlighted-arrow', true)
                    .classed('faded', false);

                // 淡化其他箭头
                arrowElements.filter(`[data-link-index!="${linkIndex}"]`)
                    .classed('faded', true);
            }
        }

        function centerRelationInView(link) {
            if (!svg || !zoom || !link) return;

            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;

            const sourceNode = graphData.nodes.find(n => n.id === sourceId);
            const targetNode = graphData.nodes.find(n => n.id === targetId);
            if (!sourceNode || !targetNode) return;

            // 计算关系中点
            const midX = (sourceNode.x + targetNode.x) / 2;
            const midY = (sourceNode.y + targetNode.y) / 2;

            // 计算两点之间的距离，用于动态调整缩放级别
            const distance = Math.sqrt(
                Math.pow(sourceNode.x - targetNode.x, 2) +
                Math.pow(sourceNode.y - targetNode.y, 2)
            );

            const container = document.getElementById('graph-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            // 减小缩放比例，使居中放大效果更小
            let scale = Math.min(containerWidth / (distance * 2.0), 2);
            scale = Math.max(scale, 0.5); // 确保缩放不会太小

            svg.transition()
                .duration(800)
                .ease(d3.easeCubic)
                .call(zoom.transform,
                    d3.zoomIdentity
                        .translate(containerWidth / 2, containerHeight / 2)
                        .scale(scale)
                        .translate(-midX, -midY)
                );
        }

        // ------------------------------
        // 详情展示与编辑功能
        // ------------------------------
        function showEntityDetail(entity) {
            selectedNode = entity;
            selectedLink = null;

            // 检查是否处于编辑状态
            const isEditing = editingEntityId === entity.id;

            // 如果是编辑状态，显示编辑页面
            if (isEditing) {
                showEntityEditPage(entity);
                return;
            }

            const relatedLinks = graphData.links.filter(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                return sourceId === entity.id || targetId === entity.id;
            });

            let relationsHtml = '';
            relatedLinks.forEach((link, index) => {
                const isSource = (typeof link.source === 'object' ? link.source.id : link.source) === entity.id;
                const otherNodeId = isSource
                    ? (typeof link.target === 'object' ? link.target.id : link.target)
                    : (typeof link.source === 'object' ? link.source.id : link.source);
                const otherNode = graphData.nodes.find(n => n.id === otherNodeId);

                const sourceId = isSource ? entity.id : otherNodeId;
                const targetId = isSource ? otherNodeId : entity.id;
                const linkIndex = graphData.links.findIndex(l => {
                    const lSourceId = typeof l.source === 'object' ? l.source.id : l.source;
                    const lTargetId = typeof l.target === 'object' ? l.target.id : l.target;
                    return lSourceId === sourceId && lTargetId === targetId && l.type === link.type;
                });

                relationsHtml += `
                    <div class="relation-item">
                        <strong>${isSource ? '→ ' : '← '}${link.type}</strong>
                        <div>${otherNode ? otherNode.name : '未知实体'}</div>
                        <div class="entity-actions" style="margin-top: 5px;">
                            <div class="action-btn edit-btn"
                                onclick="startEditRelation(${linkIndex})">
                                编辑
                            </div>
                            <div class="action-btn delete-btn"
                                onclick="deleteRelation('${sourceId}', '${targetId}', '${link.type}')">
                                删除
                            </div>
                        </div>
                    </div>
                `;
            });

            detailView.innerHTML = `
                <div class="detail-header">实体详情</div>
                <div class="detail-section">
                    <h3>实体ID</h3>
                    <div class="detail-content">${entity.id}</div>
                </div>
                <div class="detail-section">
                    <h3>实体名称</h3>
                    <div class="detail-content">${entity.name}</div>
                </div>
                <div class="detail-section">
                    <h3>图谱领域</h3>
                    <div class="detail-content">${entity.domain || 'default'}</div>
                </div>
                <div class="detail-section">
                    <h3>实体描述</h3>
                    <div class="detail-content resizable-description" id="entity-description">
                        <div class="description-text" id="description-text" data-full-text="${entity.description || '无描述'}">${entity.description && entity.description.length > 100 ? entity.description.substring(0, 100) + '...' : (entity.description || '无描述')}</div>
                        <div class="description-controls" style="display: ${entity.description && entity.description !== '无描述' ? 'flex' : 'none'}">
                            <button class="expand-btn" onclick="toggleDescription()" style="display: ${entity.description && entity.description.length > 100 ? 'inline-block' : 'none'}">展开</button>
                            <button class="copy-btn" onclick="copyDescription()">复制</button>
                        </div>
                    </div>
                </div>
                <div class="detail-section">
                    <h3>操作</h3>
                    <div class="entity-actions">
                        <div class="action-btn edit-btn" onclick="startEditEntity('${entity.id}')">
                            编辑实体
                        </div>
                        <div class="action-btn copy-btn" onclick="copyEntityWithRelation('${entity.id}')">
                            复制实体
                        </div>
                        <div class="action-btn delete-btn" onclick="deleteEntity('${entity.id}')">
                            删除实体
                        </div>
                    </div>
                </div>
                <div class="detail-section">
                    <h3>关联关系 (${relatedLinks.length})</h3>
                    <div class="detail-content">
                        ${relationsHtml || '无关联关系'}
                    </div>
                </div>
            `;
        }

        // 显示关系详情并提供编辑功能
        function showRelationDetail(link) {
            selectedLink = link;
            selectedNode = null;

            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            const sourceEntity = graphData.nodes.find(n => n.id === sourceId);
            const targetEntity = graphData.nodes.find(n => n.id === targetId);

            // 找到关系在数组中的索引
            const linkIndex = graphData.links.findIndex(l => {
                const lSourceId = typeof l.source === 'object' ? l.source.id : l.source;
                const lTargetId = typeof l.target === 'object' ? l.target.id : l.target;
                return lSourceId === sourceId && lTargetId === targetId && l.type === link.type;
            });

            // 检查是否处于编辑状态
            const isEditing = editingLinkIndex === linkIndex;

            detailView.innerHTML = `
                <div class="detail-header">关系详情</div>
                <div class="detail-section">
                    <h3>关系类型</h3>
                    <div class="detail-content">${link.type}</div>
                </div>
                <div class="detail-section">
                    <h3>源实体</h3>
                    <div class="detail-content" onclick="showEntityDetail(${JSON.stringify(sourceEntity)})"
                         style="cursor: pointer; text-decoration: underline;">
                        ${sourceEntity?.name || '未知实体'} (ID: ${sourceId})
                    </div>
                </div>
                <div class="detail-section">
                    <h3>目标实体</h3>
                    <div class="detail-content" onclick="showEntityDetail(${JSON.stringify(targetEntity)})"
                         style="cursor: pointer; text-decoration: underline;">
                        ${targetEntity?.name || '未知实体'} (ID: ${targetId})
                    </div>
                </div>
                <div class="detail-section">
                    <h3>操作</h3>
                    <div class="entity-actions">
                        <div class="action-btn edit-btn" onclick="startEditRelation(${linkIndex})">
                            编辑关系
                        </div>
                        <div class="action-btn delete-btn"
                            onclick="deleteRelation('${sourceId}', '${targetId}', '${link.type}')">
                            删除关系
                        </div>
                    </div>
                </div>

                ${isEditing ? `
                <!-- 关系编辑表单 -->
                <div class="relation-edit-form">
                    <h3 class="list-title">编辑关系</h3>
                    <div class="form-group">
                        <label for="edit-source-entity-display">源实体</label>
                        <div class="entity-select-container">
                            <input type="text" id="edit-source-entity-display"
                                   value="${sourceEntity?.name || ''}"
                                   placeholder="选择或搜索源实体">
                            <input type="hidden" id="edit-source-entity" value="${sourceId}">
                            <div class="entity-dropdown" id="edit-source-entity-dropdown"></div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="edit-target-entity-display">目标实体</label>
                        <div class="entity-select-container">
                            <input type="text" id="edit-target-entity-display"
                                   value="${targetEntity?.name || ''}"
                                   placeholder="选择或搜索目标实体">
                            <input type="hidden" id="edit-target-entity" value="${targetId}">
                            <div class="entity-dropdown" id="edit-target-entity-dropdown"></div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="edit-relation-type-display">关系类型</label>
                        <div class="relation-type-select-container">
                            <input type="text" id="edit-relation-type-display"
                                   value="${link.type}"
                                   placeholder="输入或选择关系类型">

                            <input type="hidden" id="edit-relation-type" value="${link.type}">
                            <div class="relation-type-dropdown" id="edit-relation-type-dropdown"></div>
                        </div>
                    </div>
                    <div class="btn-group">
                        <button id="save-relation-edit" class="btn-primary"
                            onclick="saveRelationEdit(${linkIndex})">保存修改</button>
                        <button class="btn-secondary" onclick="cancelRelationEdit()">取消</button>
                    </div>
                </div>
                ` : ''}
            `;

            // 只有在编辑状态下才初始化下拉框
            if (isEditing) {
                // 初始化编辑关系时的实体选择下拉框
                initEditRelationDropdowns();

                // 初始化编辑关系时的关系类型下拉框
                initEditRelationTypeDropdown();
            }
        }

        // 初始化编辑关系时的实体选择下拉框
        function initEditRelationDropdowns() {
            const editSourceDisplay = document.getElementById('edit-source-entity-display');
            const editSourceInput = document.getElementById('edit-source-entity');
            const editSourceDropdown = document.getElementById('edit-source-entity-dropdown');

            const editTargetDisplay = document.getElementById('edit-target-entity-display');
            const editTargetInput = document.getElementById('edit-target-entity');
            const editTargetDropdown = document.getElementById('edit-target-entity-dropdown');

            // 按添加时间排序，最近添加的在前面
            const sortedEntities = [...graphData.nodes].reverse();

            // 填充源实体下拉框
            updateEntityDropdown(editSourceDropdown, sortedEntities);

            // 填充目标实体下拉框
            updateEntityDropdown(editTargetDropdown, sortedEntities);

            // 为源实体输入框添加事件监听
            editSourceDisplay.addEventListener('focus', () => {
                editSourceDropdown.classList.add('visible');
            });

            editSourceDisplay.addEventListener('input', () => {
                const filtered = filterEntities(editSourceDisplay.value);
                updateEntityDropdown(editSourceDropdown, filtered);
                editSourceDropdown.classList.add('visible');
            });

            // 为目标实体输入框添加事件监听
            editTargetDisplay.addEventListener('focus', () => {
                editTargetDropdown.classList.add('visible');
            });

            editTargetDisplay.addEventListener('input', () => {
                const filtered = filterEntities(editTargetDisplay.value);
                updateEntityDropdown(editTargetDropdown, filtered);
                editTargetDropdown.classList.add('visible');
            });

            // 添加点击外部关闭下拉框的事件
            document.addEventListener('click', (e) => {
                if (!editSourceDisplay.contains(e.target) && !editSourceDropdown.contains(e.target)) {
                    editSourceDropdown.classList.remove('visible');
                }
                if (!editTargetDisplay.contains(e.target) && !editTargetDropdown.contains(e.target)) {
                    editTargetDropdown.classList.remove('visible');
                }
            });
        }

        // 初始化编辑关系时的关系类型下拉框
        function initEditRelationTypeDropdown() {
            const editRelationTypeDisplay = document.getElementById('edit-relation-type-display');
            const editRelationTypeInput = document.getElementById('edit-relation-type');
            const editRelationTypeDropdown = document.getElementById('edit-relation-type-dropdown');

            // 填充关系类型下拉框
            updateRelationTypeDropdownForEdit(editRelationTypeDropdown);

            // 为关系类型输入框添加事件监听
            editRelationTypeDisplay.addEventListener('focus', () => {
                editRelationTypeDropdown.classList.add('visible');
            });

            editRelationTypeDisplay.addEventListener('input', () => {
                const inputValue = editRelationTypeDisplay.value.trim();
                const filtered = filterRelationTypes(inputValue);
                // 清空下拉框
                editRelationTypeDropdown.innerHTML = '';

                // 1. 添加自定义输入选项（若输入不为空且未匹配现有类型）
                if (inputValue && !filtered.includes(inputValue)) {
                    const customItem = document.createElement('div');
                    customItem.className = 'dropdown-item';
                    customItem.textContent = `自定义: ${inputValue}`;
                    customItem.dataset.type = inputValue;
                    customItem.style.color = '#2e7d32';

                    customItem.addEventListener('click', () => {
                        editRelationTypeInput.value = inputValue;
                        editRelationTypeDisplay.value = inputValue;
                        editRelationTypeDropdown.classList.remove('visible');
                    });

                    editRelationTypeDropdown.appendChild(customItem);
                }

                // 2. 添加过滤后的现有类型
                if (filtered.length === 0 && !inputValue) {
                    const emptyItem = document.createElement('div');
                    emptyItem.className = 'dropdown-item';
                    emptyItem.textContent = '无匹配的关系类型';
                    emptyItem.style.cursor = 'default';
                    emptyItem.style.opacity = '0.7';
                    editRelationTypeDropdown.appendChild(emptyItem);
            } else {
                    filtered.forEach(type => {
                        const item = document.createElement('div');
                        item.className = 'dropdown-item';
                        item.textContent = type;
                        item.dataset.type = type;

                        item.addEventListener('click', () => {
                            editRelationTypeInput.value = type;
                            editRelationTypeDisplay.value = type;
                            editRelationTypeDropdown.classList.remove('visible');
                        });

                        editRelationTypeDropdown.appendChild(item);
                    });
                }
                editRelationTypeDropdown.classList.add('visible');
            });

            // 3. 失去焦点时保存自定义输入
            editRelationTypeDisplay.addEventListener('blur', () => {
                const inputValue = editRelationTypeDisplay.value.trim();
                if (inputValue) {
                    editRelationTypeInput.value = inputValue;
                    setTimeout(() => {
                        editRelationTypeDropdown.classList.remove('visible');
                    }, 200);
                }
            });

            // 为关系类型下拉框中的选项添加点击事件
            editRelationTypeDropdown.querySelectorAll('.dropdown-item').forEach(item => {
                item.addEventListener('click', () => {
                    editRelationTypeInput.value = item.dataset.type;
                    editRelationTypeDisplay.value = item.dataset.type;
                    editRelationTypeDropdown.classList.remove('visible');
                });
            });
        }

        // 更新编辑关系时的关系类型下拉框
        function updateRelationTypeDropdownForEdit(dropdownElement, types) {
            dropdownElement.innerHTML = '';

            const relationTypes = types || Array.from(usedRelationTypes).sort();

            if (relationTypes.length === 0) {
                const emptyItem = document.createElement('div');
                emptyItem.className = 'dropdown-item';
                emptyItem.textContent = '暂无关系类型';
                emptyItem.style.cursor = 'default';
                emptyItem.style.opacity = '0.7';
                dropdownElement.appendChild(emptyItem);
                return;
            }

            relationTypes.forEach(type => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                item.textContent = type;
                item.dataset.type = type;

                dropdownElement.appendChild(item);
            });
        }

        // 保存关系编辑
        async function saveRelationEdit(linkIndex) {
            if (linkIndex < 0 || linkIndex >= graphData.links.length) return;

            const sourceId = document.getElementById('edit-source-entity').value;
            const targetId = document.getElementById('edit-target-entity').value;
            const type = document.getElementById('edit-relation-type').value.trim();

            if (!sourceId || !targetId || !type) {
                alert('请完善关系信息');
                return;
            }

            if (sourceId === targetId) {
                alert('源实体和目标实体不能相同');
                return;
            }

            // 检查更新后的关系是否已存在（排除自身）
            const relationExists = graphData.links.some((link, index) => {
                if (index === linkIndex) return false;

                const lSourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const lTargetId = typeof link.target === 'object' ? link.target.id : link.target;
                return lSourceId === sourceId && lTargetId === targetId && link.type === type;
            });

            if (relationExists) {
                alert('此关系已存在');
                return;
            }

            // 获取原始关系数据用于API调用
            const originalLink = graphData.links[linkIndex];
            const originalSourceId = typeof originalLink.source === 'object' ? originalLink.source.id : originalLink.source;
            const originalTargetId = typeof originalLink.target === 'object' ? originalLink.target.id : originalLink.target;
            const originalType = originalLink.type;

            try {
                // 首先获取关系的ID
                console.log('开始获取关系数据...');
                const relationshipResponse = await fetch('/api/kg/data');
                if (!relationshipResponse.ok) {
                    throw new Error(`Failed to fetch relationship data: ${relationshipResponse.status}`);
                }
                const relationshipData = await relationshipResponse.json();
                console.log('获取到的关系数据:', relationshipData);
                
                // 检查数据结构
                if (!relationshipData.data || !relationshipData.data.links) {
                    throw new Error('Invalid data structure: missing data.links');
                }
                
                // 找到要更新的关系
                const relationshipToUpdate = relationshipData.data.links.find(link => 
                    link.source === originalSourceId && 
                    link.target === originalTargetId && 
                    link.type === originalType
                );
                
                console.log('要更新的关系:', relationshipToUpdate);
                console.log('搜索条件:', { originalSourceId, originalTargetId, originalType });
                
                if (!relationshipToUpdate) {
                    throw new Error('Relationship not found');
                }
                
                // 调用后端API更新关系
                const updateData = {
                    source: sourceId,
                    target: targetId,
                    type: type
                };
                
                console.log('发送更新数据:', updateData);
                console.log('API URL:', `/api/kg/relationships/${relationshipToUpdate.id}`);
                
                const response = await fetch(`/api/kg/relationships/${relationshipToUpdate.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify(updateData)
                });

                console.log('API响应状态:', response.status);
                console.log('API响应头:', response.headers);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API错误响应:', errorText);
                    throw new Error(`HTTP error! status: ${response.status}, response: ${errorText}`);
                }

                const result = await response.json();
                console.log('API响应结果:', result);
                
                if (result.success || result.ret === 0) {
                    // 更新本地数据
                    graphData.links[linkIndex] = {
                        source: sourceId,
                        target: targetId,
                        type: type
                    };

                    // 局部更新数据
                    updateGraphDataLocally();
                    
                    alert('关系更新成功');

                    // 重新显示更新后的关系详情
                    showRelationDetail(graphData.links[linkIndex]);
                    
                    // 重置编辑状态
                    editingLinkIndex = -1;

                    // 延迟一下等待图表重新渲染完成后居中展示更新后的关系
                    setTimeout(() => {
                        centerOnRelation(sourceId, targetId, type);
                    }, 100);
                } else {
                    alert('关系更新失败: ' + (result.message || result.msg || '未知错误'));
                }
            } catch (error) {
                console.error('更新关系失败:', error);
                alert('关系更新失败: ' + error.message);
            }
        }

        // 取消关系编辑
        function cancelRelationEdit() {
            // 重置编辑状态
            editingLinkIndex = -1;
            
            // 清空关系表单
            clearRelationForm();
            
            // 如果之前有选中的关系，重新显示其详情
            if (selectedLink) {
                showRelationDetail(selectedLink);
            } else {
                detailView.innerHTML = '<div class="no-data">选择一个实体或关系查看详情</div>';
            }
            
            console.log('关系编辑已取消');
        }

        // 显示实体编辑页面
        function showEntityEditPage(entity) {
            detailView.innerHTML = `
                <div class="detail-header">编辑实体</div>
                <div class="entity-edit-form">
                    <div class="form-group">
                        <label for="edit-entity-id">实体ID</label>
                        <input type="text" id="edit-entity-id" value="${entity.id}" readonly>
                    </div>
                    <div class="form-group">
                        <label for="edit-entity-name">实体名称</label>
                        <input type="text" id="edit-entity-name" value="${entity.name}" placeholder="输入实体名称">
                    </div>
                    <div class="form-group">
                        <label for="edit-entity-domain">图谱领域</label>
                        <select id="edit-entity-domain">
                            <option value="default" ${entity.domain === 'default' ? 'selected' : ''}>默认领域</option>
                            <option value="technology" ${entity.domain === 'technology' ? 'selected' : ''}>技术领域</option>
                            <option value="medicine" ${entity.domain === 'medicine' ? 'selected' : ''}>医学领域</option>
                            <option value="finance" ${entity.domain === 'finance' ? 'selected' : ''}>金融领域</option>
                            <option value="education" ${entity.domain === 'education' ? 'selected' : ''}>教育领域</option>
                            <option value="culture" ${entity.domain === 'culture' ? 'selected' : ''}>文化领域</option>
                            <option value="custom" ${!['default', 'technology', 'medicine', 'finance', 'education', 'culture'].includes(entity.domain) ? 'selected' : ''}>自定义领域</option>
                        </select>
                        <input type="text" id="edit-custom-domain" placeholder="输入自定义领域名称" style="display: none; margin-top: 5px; width: 100%;" value="${!['default', 'technology', 'medicine', 'finance', 'education', 'culture'].includes(entity.domain) ? entity.domain : ''}">
                    </div>
                    <div class="form-group">
                        <label for="edit-entity-desc">实体描述</label>
                        <textarea id="edit-entity-desc" rows="3" placeholder="输入实体描述">${entity.description || ''}</textarea>
                    </div>
                    <div class="btn-group">
                        <button id="save-entity-edit" class="btn-primary" onclick="saveEntityEdit()">更新实体</button>
                        <button class="btn-secondary" onclick="cancelEntityEdit()">取消</button>
                    </div>
                </div>
            `;

            // 初始化编辑表单事件
            initEntityEditForm();
        }

        // 初始化实体编辑表单
        function initEntityEditForm() {
            const editEntityDomain = document.getElementById('edit-entity-domain');
            const editCustomDomain = document.getElementById('edit-custom-domain');

            // 领域选择事件监听器
            editEntityDomain.addEventListener('change', function() {
                if (this.value === 'custom') {
                    editCustomDomain.style.display = 'block';
                    editCustomDomain.focus();
                } else {
                    editCustomDomain.style.display = 'none';
                    editCustomDomain.value = '';
                }
            });

            // 如果当前选中的是自定义领域，显示自定义输入框
            if (editEntityDomain.value === 'custom') {
                editCustomDomain.style.display = 'block';
            }
        }

        // 保存实体编辑
        async function saveEntityEdit() {
            if (!editingEntityId) return;

            const entity = graphData.nodes.find(n => n.id === editingEntityId);
            if (!entity) {
                alert('实体不存在');
                cancelEntityEdit();
                return;
            }

            const name = document.getElementById('edit-entity-name').value.trim();
            const description = document.getElementById('edit-entity-desc').value.trim();
            
            // 获取领域信息
            let domain = document.getElementById('edit-entity-domain').value;
            if (domain === 'custom') {
                domain = document.getElementById('edit-custom-domain').value.trim();
                if (!domain) {
                    alert('请输入自定义领域名称');
                    return;
                }
            }

            if (!name) {
                alert('实体名称不能为空');
                return;
            }

            const updateData = { name, domain };
            if (description) {
                updateData.description = description;
            }

            // 调用后端API更新实体
            const success = await updateEntityAPI(editingEntityId, updateData);
            if (success) {
                // 更新本地数据
                Object.assign(entity, updateData);
                
                // 局部更新数据
                updateGraphDataLocally();
                
                // 更新详情视图
                const updatedEntity = graphData.nodes.find(n => n.id === editingEntityId);
                if (updatedEntity) {
                    // 保存实体ID用于居中展示
                    const entityIdToCenter = editingEntityId;
                    
                    // 重置编辑状态并显示详情页
                    editingEntityId = null;
                    showEntityDetail(updatedEntity);
                    
                    // 等待D3.js simulation稳定后居中放大展示更新后的实体
                    const waitForSimulation = () => {
                        if (simulation && simulation.alpha() > 0.01) {
                            // simulation还在运行，继续等待
                            setTimeout(waitForSimulation, 50);
                        } else {
                            // simulation已稳定，执行居中放大
                            setTimeout(() => {
                                // 清除所有高亮
                                clearAllHighlights();
                                
                                // 高亮更新后的实体
                                const updatedNodeGroup = d3.selectAll('.node').filter(d => d.id === entityIdToCenter);
                                if (!updatedNodeGroup.empty()) {
                                    updatedNodeGroup.classed('highlighted', true);
                                }
                                
                                // 居中放大显示
                                centerNodeInView(entityIdToCenter);
                            }, 100);
                        }
                    };
                    waitForSimulation();
                }

                alert('实体更新成功');
            } else {
                alert('实体更新失败，请检查网络连接');
            }
        }

        // 取消实体编辑
        function cancelEntityEdit() {
            // 重置编辑状态
            editingEntityId = null;
            
            // 如果之前有选中的实体，重新显示其详情
            if (selectedNode) {
                showEntityDetail(selectedNode);
            } else {
                detailView.innerHTML = '<div class="no-data">选择一个实体或关系查看详情</div>';
            }
            
            console.log('实体编辑已取消');
        }

        // 重置搜索状态
        function resetSearchState() {
            searchResults = [];
            currentResultIndex = -1;
            lastSearchKeyword = '';
            lastSearchType = searchTypeSelect.value;
            searchResultsInfo.textContent = '';
        }

        // ------------------------------
        // 搜索与轮询显示功能 - 按类型搜索
        // ------------------------------
        function searchAndLocate() {
            const keyword = searchInput.value.trim().toLowerCase();
            const searchType = searchTypeSelect.value;

            if (!keyword) {
                resetSearchState();
                return;
            }

            const isNewSearch = keyword !== lastSearchKeyword || searchType !== lastSearchType;

            if (isNewSearch) {
                lastSearchKeyword = keyword;
                lastSearchType = searchType;
                searchResults = [];

                // 根据选择的搜索类型进行搜索
                switch(searchType) {
                    case 'entityId':
                        // 按实体ID搜索（精确匹配）
                        const idMatch = graphData.nodes.find(node => node.id === keyword);
                        if (idMatch) {
                            searchResults.push({
                                type: 'entity',
                                data: idMatch
                            });
                        }
                        break;

                    case 'entityName':
                        // 按实体名称搜索（模糊匹配）
                        graphData.nodes.forEach(node => {
                            if (node.name.toLowerCase().includes(keyword)) {
                                searchResults.push({
                                    type: 'entity',
                                    data: node
                                });
                            }
                        });
                        break;

                    case 'entityDesc':
                        // 按实体描述搜索（模糊匹配）
                        graphData.nodes.forEach(node => {
                            if (node.description && node.description.toLowerCase().includes(keyword)) {
                                searchResults.push({
                                    type: 'entity',
                                    data: node
                                });
                            }
                        });
                        break;

                    case 'relation':
                        // 按关系类型搜索（模糊匹配）
                        graphData.links.forEach(link => {
                            if (link.type.toLowerCase().includes(keyword)) {
                                searchResults.push({
                                    type: 'relation',
                                    data: link
                                });
                            }
                        });
                        break;
                }

                currentResultIndex = 0;
            } else {
                if (searchResults.length > 0) {
                    currentResultIndex = (currentResultIndex + 1) % searchResults.length;
                }
            }

            if (searchResults.length === 0) {
                const searchTypeName = document.querySelector(`#search-type option[value="${searchType}"]`).text;
                searchResultsInfo.textContent = `未找到匹配"${searchTypeName}"的结果`;
                detailView.innerHTML = `<div class="no-data">未找到匹配"${searchTypeName}"的实体或关系</div>`;
                clearAllHighlights();
                return;
            }

            const searchTypeName = document.querySelector(`#search-type option[value="${searchType}"]`).text;
            searchResultsInfo.textContent = `找到 ${searchResults.length} 个匹配"${searchTypeName}"的结果，显示第 ${currentResultIndex + 1} 个`;

            const currentResult = searchResults[currentResultIndex];
            if (currentResult.type === 'entity') {
                const entity = currentResult.data;
                showEntityDetail(entity);
                centerNodeInView(entity.id);
                highlightSearchEntity(entity.id);
            } else if (currentResult.type === 'relation') {
                const link = currentResult.data;
                showRelationDetail(link);
                centerRelationInView(link);
                highlightSearchRelation(link);
            }
        }

        // ------------------------------
        // 事件监听绑定
        // ------------------------------
        function setupEventListeners() {
            setupFileEventListeners();

            // 领域选择事件监听器
            entityDomainSelect.addEventListener('change', function() {
                if (this.value === 'custom') {
                    customDomainInput.style.display = 'block';
                    customDomainInput.focus();
                } else {
                    customDomainInput.style.display = 'none';
                    customDomainInput.value = '';
                }
            });

            addEntityBtn.addEventListener('click', addEntity);
            updateEntityBtn.addEventListener('click', updateEntity);
            cancelEditBtn.addEventListener('click', cancelEdit);
            clearEntityFormBtn.addEventListener('click', () => {
                clearEntityForm();
                // 重新填充默认值
                populateDefaultEntityValues();
            });

            addRelationBtn.addEventListener('click', addRelation);
            clearRelationFormBtn.addEventListener('click', clearRelationForm);

            // 清空所有数据按钮事件
            document.getElementById('clear-all-data').addEventListener('click', clearAllData);

            searchBtn.addEventListener('click', searchAndLocate);
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') searchAndLocate();
            });

                    zoomInBtn.addEventListener('click', zoomIn);
        zoomOutBtn.addEventListener('click', zoomOut);
        fitViewBtn.addEventListener('click', fitView);
        resetViewBtn.addEventListener('click', resetLayout);

            // 源实体选择框事件
            sourceEntityDisplay.addEventListener('focus', () => {
                sourceEntityDropdown.classList.add('visible');
                sourceEntityDropdown.classList.add('visible');
            });

            sourceEntityDisplay.addEventListener('input', () => {
                const filtered = filterEntities(sourceEntityDisplay.value);
                updateEntityDropdown(sourceEntityDropdown, filtered);
                sourceEntityDropdown.classList.add('visible');
            });

            // 目标实体选择框事件
            targetEntityDisplay.addEventListener('focus', () => {
                targetEntityDropdown.classList.add('visible');
            });

            targetEntityDisplay.addEventListener('input', () => {
                const filtered = filterEntities(targetEntityDisplay.value);
                updateEntityDropdown(targetEntityDropdown, filtered);
                targetEntityDropdown.classList.add('visible');
            });

            // 关系类型选择框事件
            relationTypeDisplay.addEventListener('focus', () => {
                relationTypeDropdown.classList.add('visible');
            });

            relationTypeDisplay.addEventListener('input', () => {
                const inputValue = relationTypeDisplay.value.trim();
                const filtered = filterRelationTypes(inputValue);
                // 更新关系类型下拉框
                relationTypeDropdown.innerHTML = '';

                // 1. 若输入不为空，添加"自定义输入"选项
                if (inputValue && !filtered.includes(inputValue)) {
                    const customItem = document.createElement('div');
                    customItem.className = 'dropdown-item';
                    customItem.textContent = `自定义: ${inputValue}`;
                    customItem.dataset.type = inputValue;
                    customItem.style.color = '#2e7d32'; // 高亮自定义选项

                    customItem.addEventListener('click', () => {
                        relationTypeInput.value = inputValue;
                        relationTypeDisplay.value = inputValue;
                        relationTypeDropdown.classList.remove('visible');
                    });

                    relationTypeDropdown.appendChild(customItem);
                }

                // 2. 添加过滤后的现有关系类型
                if (filtered.length === 0 && !inputValue) {
                    const emptyItem = document.createElement('div');
                    emptyItem.className = 'dropdown-item';
                    emptyItem.textContent = '无匹配的关系类型';
                    emptyItem.style.cursor = 'default';
                    emptyItem.style.opacity = '0.7';
                    relationTypeDropdown.appendChild(emptyItem);
                } else {
                    filtered.forEach(type => {
                        const item = document.createElement('div');
                        item.className = 'dropdown-item';
                        item.textContent = type;
                        item.dataset.type = type;

                        item.addEventListener('click', () => {
                            relationTypeInput.value = type;
                            relationTypeDisplay.value = type;
                            relationTypeDropdown.classList.remove('visible');
                        });

                        relationTypeDropdown.appendChild(item);
                    });
                }
                relationTypeDropdown.classList.add('visible');
            });

            // 3. 失去焦点时保存自定义输入（若未选择下拉项）
            relationTypeDisplay.addEventListener('blur', () => {
                const inputValue = relationTypeDisplay.value.trim();
                if (inputValue) {
                    // 直接将输入值设为关系类型（无需依赖下拉框选择）
                    relationTypeInput.value = inputValue;
                    // 关闭下拉框
                    setTimeout(() => {
                        relationTypeDropdown.classList.remove('visible');
                    }, 200);
                }
            });

            // 点击其他区域关闭下拉框
            document.addEventListener('click', (event) => {
                if (!event.target.closest('.entity-select-container') &&
                    !event.target.closest('.relation-type-select-container')) {
                    sourceEntityDropdown.classList.remove('visible');
                    targetEntityDropdown.classList.remove('visible');
                    relationTypeDropdown.classList.remove('visible');

                    // 关闭编辑关系时的下拉框
                    const editSourceDropdown = document.getElementById('edit-source-entity-dropdown');
                    const editTargetDropdown = document.getElementById('edit-target-entity-dropdown');
                    const editRelationTypeDropdown = document.getElementById('edit-relation-type-dropdown');

                    if (editSourceDropdown) editSourceDropdown.classList.remove('visible');
                    if (editTargetDropdown) editTargetDropdown.classList.remove('visible');
                    if (editRelationTypeDropdown) editRelationTypeDropdown.classList.remove('visible');
                }
            });

            // 窗口大小变化时重绘图谱
            window.addEventListener('resize', () => {
                if (graphData.nodes.length > 0) {
                    reloadGraph();
                    fitView();
                }
            });
        }

        // 全局函数，用于关系编辑操作
        window.startEditRelation = startEditRelation;
        window.deleteRelation = deleteRelation;
        window.startEditEntity = startEditEntity;
        window.deleteEntity = deleteEntity;
        window.showEntityDetail = showEntityDetail;
        window.saveRelationEdit = saveRelationEdit;
        window.cancelRelationEdit = cancelRelationEdit;
        window.saveEntityEdit = saveEntityEdit;
        window.cancelEntityEdit = cancelEntityEdit;
        window.toggleDescription = toggleDescription;
        window.copyDescription = copyDescription;
        window.copyEntityWithRelation = copyEntityWithRelation;

        // AI聊天机器人功能
        let aiChatOpen = false;

        // 切换AI聊天窗口
        function toggleAIChat() {
            const chatWindow = document.getElementById('aiChatWindow');
            aiChatOpen = !aiChatOpen;
            
            if (aiChatOpen) {
                chatWindow.style.display = 'flex';
                document.getElementById('aiInputField').focus();
            } else {
                chatWindow.style.display = 'none';
            }
        }

        // 处理AI输入框回车键
        function handleAIKeyPress(event) {
            if (event.key === 'Enter') {
                sendAIMessage();
            }
        }

        // 发送AI消息
        async function sendAIMessage() {
            const inputField = document.getElementById('aiInputField');
            const sendBtn = document.getElementById('aiSendBtn');
            const message = inputField.value.trim();
            
            if (!message) return;

            // 禁用输入和发送按钮
            inputField.disabled = true;
            sendBtn.disabled = true;

            // 添加用户消息
            addAIMessage(message, 'user');
            inputField.value = '';

            // 显示AI正在输入
            showAITyping();

            try {
                // 调用AI问答API
                const response = await getAIResponse(message);
                hideAITyping();
                addAIMessage(response, 'bot');
            } catch (error) {
                hideAITyping();
                addAIMessage('抱歉，我遇到了一些问题。请稍后再试。', 'bot');
                console.error('AI响应错误:', error);
            }

            // 重新启用输入和发送按钮
            inputField.disabled = false;
            sendBtn.disabled = false;
            inputField.focus();
        }

        // 添加AI消息到聊天窗口
        function addAIMessage(content, sender) {
            const messagesContainer = document.getElementById('aiChatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `ai-message ${sender}`;
            
            const avatar = document.createElement('div');
            avatar.className = 'ai-message-avatar';
            
            if (sender === 'user') {
                avatar.textContent = '我';
            } else {
                // 为AI消息创建史努比头像
                avatar.innerHTML = `
                    <div class="snoopy-avatar">
                        <div class="snoopy-head"></div>
                        <div class="snoopy-ears">
                            <div class="ear left-ear"></div>
                            <div class="ear right-ear"></div>
                        </div>
                        <div class="snoopy-eyes">
                            <div class="eye left-eye"></div>
                            <div class="eye right-eye"></div>
                        </div>
                        <div class="snoopy-nose"></div>
                    </div>
                `;
            }
            
            const messageContent = document.createElement('div');
            messageContent.className = 'ai-message-content';
            messageContent.textContent = content;
            
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(messageContent);
            messagesContainer.appendChild(messageDiv);
            
            // 滚动到底部
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // 显示AI正在输入
        function showAITyping() {
            document.getElementById('aiTyping').style.display = 'block';
            const messagesContainer = document.getElementById('aiChatMessages');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // 隐藏AI正在输入
        function hideAITyping() {
            document.getElementById('aiTyping').style.display = 'none';
        }

        // 获取AI响应
        async function getAIResponse(userMessage) {
            try {
                // 获取AI开关状态
                const useExternalAI = document.getElementById('aiSwitch').classList.contains('active');
                
                // 准备上下文数据
                const contextData = {
                    message: userMessage,
                    graphData: {
                        nodes: graphData.nodes || [],
                        links: graphData.links || []
                    },
                    currentDomain: currentDomain,
                    selectedNode: selectedNode,
                    selectedLink: selectedLink,
                    useExternalAI: useExternalAI  // 添加AI开关状态
                };

                // 调用后端AI问答API
                const response = await fetch('/api/kg/ai-chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(contextData)
                });

                if (!response.ok) {
                    throw new Error('AI服务暂时不可用');
                }

                const result = await response.json();
                return result.response || '抱歉，我无法理解您的问题。';
            } catch (error) {
                // 如果API不可用，使用本地智能回复
                return generateLocalAIResponse(userMessage);
            }
        }

        // AI开关切换函数
        function toggleAISwitch() {
            const aiSwitch = document.getElementById('aiSwitch');
            const aiSwitchText = document.getElementById('aiSwitchText');
            
            if (aiSwitch.classList.contains('active')) {
                // 切换到本地AI
                aiSwitch.classList.remove('active');
                aiSwitchText.textContent = '本地';
                aiSwitchText.style.color = 'white';
            } else {
                // 切换到外部AI
                aiSwitch.classList.add('active');
                aiSwitchText.textContent = '外部';
                aiSwitchText.style.color = 'white';
            }
        }

        // 本地智能回复（当后端AI服务不可用时）
        function generateLocalAIResponse(userMessage) {
            const message = userMessage.toLowerCase();
            
            // 模糊搜索实体
            function fuzzySearchEntities(query) {
                const results = [];
                const queryLower = query.toLowerCase();
                for (const node of graphData.nodes) {
                    const nodeName = node.name.toLowerCase();
                    const nodeId = node.id.toLowerCase();
                    const nodeDesc = (node.description || '').toLowerCase();
                    
                    if (queryLower.includes(nodeName) || 
                        queryLower.includes(nodeId) || 
                        queryLower.includes(nodeDesc)) {
                        results.push(node);
                    }
                }
                return results;
            }
            
            // 实体相关查询
            if (message.includes('实体') || message.includes('节点') || message.includes('什么') || message.includes('哪些') || message.includes('谁') || message.includes('哪里')) {
                // 模糊搜索
                const searchResults = fuzzySearchEntities(message);
                if (searchResults.length > 0) {
                    if (searchResults.length === 1) {
                        const node = searchResults[0];
                        const relatedLinks = graphData.links.filter(l => 
                            (typeof l.source === 'object' ? l.source.id : l.source) === node.id ||
                            (typeof l.target === 'object' ? l.target.id : l.target) === node.id
                        );
                        return `我找到了实体：${node.name}（${node.domain || 'default'}领域），有 ${relatedLinks.length} 个相关关系。`;
                    } else {
                        const names = searchResults.slice(0, 5).map(n => n.name);
                        return `我找到了${searchResults.length}个相关实体：${names.join('、')}`;
                    }
                }
                
                if (message.includes('数量') || message.includes('多少个')) {
                    return `当前知识图谱中共有 ${graphData.nodes.length} 个实体。`;
                }
                if (message.includes('列表') || message.includes('所有')) {
                    const entityNames = graphData.nodes.map(n => n.name).join('、');
                    return `所有实体包括：${entityNames}`;
                }
                if (message.includes('领域') || message.includes('domain')) {
                    const domains = [...new Set(graphData.nodes.map(n => n.domain || 'default'))];
                    return `图谱中的领域包括：${domains.join('、')}`;
                }
            }
            
            // 关系相关查询
            if (message.includes('关系') || message.includes('连接') || message.includes('link') || message.includes('关联')) {
                if (message.includes('数量') || message.includes('多少个')) {
                    return `当前知识图谱中共有 ${graphData.links.length} 个关系。`;
                }
                if (message.includes('类型') || message.includes('关系类型')) {
                    const relationTypes = [...new Set(graphData.links.map(l => l.type))];
                    return `关系类型包括：${relationTypes.join('、')}`;
                }
            }
            
            // 统计信息查询
            if (message.includes('统计') || message.includes('总结') || message.includes('概况')) {
                const domains = [...new Set(graphData.nodes.map(n => n.domain || 'default'))];
                const relationTypes = [...new Set(graphData.links.map(l => l.type))];
                return `知识图谱统计：共有 ${graphData.nodes.length} 个实体，${graphData.links.length} 个关系，涉及 ${domains.length} 个领域，${relationTypes.length} 种关系类型。`;
            }
            
            // 帮助信息
            if (message.includes('帮助') || message.includes('help') || message.includes('能做什么')) {
                return `我是史努比AI助手，可以帮您：

1. 查询实体信息：询问特定实体、实体数量、列表等
2. 查询关系信息：询问关系类型、连接情况等
3. 模糊搜索：即使不知道确切名称也能找到相关实体
4. 统计分析：图谱整体概况和统计信息
5. 智能问答：基于知识图谱数据回答各种问题

请告诉我您想了解什么？`;
            }
            
            // 通用回复
            return "我理解您的问题，让我为您搜索相关信息。您可以询问实体、关系、统计信息，或者直接描述您想了解的内容，我会尽力帮您找到答案。";
        }

        // 清空所有数据
        async function clearAllData() {
            // 确认对话框
            const confirmMessage = `确定要清空所有数据吗？\n\n此操作将：\n1. 自动备份当前数据为JSON文件\n2. 删除MySQL数据库中的所有数据\n3. 清空界面显示\n\n此操作不可撤销！`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                // 显示加载状态
                const clearButton = document.getElementById('clear-all-data');
                if (clearButton) {
                    const originalText = clearButton.textContent;
                    clearButton.textContent = '清空中...';
                    clearButton.disabled = true;
                }
                
                // 1. 自动备份当前数据
                const backupData = {
                    nodes: graphData.nodes.map(node => ({
                        id: node.id,
                        name: node.name,
                        description: node.description || '',
                        domain: node.domain || 'default'
                    })),
                    links: graphData.links.map(link => ({
                        source: typeof link.source === 'object' ? link.source.id : link.source,
                        target: typeof link.target === 'object' ? link.target.id : link.target,
                        type: link.type,
                        description: link.description || '',
                        domain: link.domain || 'default'
                    }))
                };
                
                // 创建并下载备份文件
                const backupBlob = new Blob([JSON.stringify(backupData, null, 2)], { type: 'application/json' });
                const backupUrl = URL.createObjectURL(backupBlob);
                const backupLink = document.createElement('a');
                backupLink.href = backupUrl;
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const timestamp = `${year}${month}${day}_${hours}${minutes}${seconds}`;
                backupLink.download = `kg_${timestamp}_backup.json`;
                document.body.appendChild(backupLink);
                backupLink.click();
                document.body.removeChild(backupLink);
                URL.revokeObjectURL(backupUrl);
                
                console.log('数据备份完成');
                
                // 2. 调用后端API清空数据
                const result = await clearAllDataAPI();
                
                if (result && (result.success || result.ret === 0)) {
                    // 3. 清空本地数据
                    graphData = { nodes: [], links: [] };
                    allGraphData = { nodes: [], links: [] };
                    filteredGraphData = { nodes: [], links: [] };
                    
                    // 4. 更新界面
                    updateGraphDataLocally();
                    
                    // 5. 清空实体列表
                    renderEntityList();
                    
                    // 6. 清空搜索状态
                    searchResults = [];
                    currentResultIndex = -1;
                    lastSearchKeyword = '';
                    lastSearchType = 'entityName';
                    
                    // 7. 清空选中状态
                    selectedNode = null;
                    selectedLink = null;
                    editingEntityId = null;
                    editingLinkIndex = -1;
                    
                    // 8. 重置领域选择
                    currentDomain = 'all';
                    const domainSelect = document.getElementById('domain-select');
                    if (domainSelect) {
                        domainSelect.value = 'all';
                    }
                    
                    // 9. 清空右侧详情面板
                    const detailPanel = document.getElementById('entity-detail-panel');
                    if (detailPanel) {
                        detailPanel.innerHTML = '<div class="no-data">暂无数据</div>';
                    } else {
                        // 如果没有找到entity-detail-panel，尝试清空detail-view
                        const detailView = document.getElementById('detail-view');
                        if (detailView) {
                            detailView.innerHTML = '<div class="no-data">暂无数据</div>';
                        }
                    }
                    
                    // 10. 显示成功消息
                    const successMessage = `数据清空成功！\n\n已删除：\n- ${result.deleted_count.entities} 个实体\n- ${result.deleted_count.relationships} 个关系\n\n数据已自动备份到本地文件。`;
                    alert(successMessage);
                    
                } else {
                    throw new Error(result ? result.message : '清空数据失败');
                }
                
            } catch (error) {
                console.error('清空数据失败:', error);
                alert(`清空数据失败：${error.message}\n\n数据备份已完成，但数据库清空失败。`);
            } finally {
                // 恢复按钮状态
                const clearButton = document.getElementById('clear-all-data');
                if (clearButton) {
                    clearButton.textContent = '一键清空数据';
                    clearButton.disabled = false;
                }
            }
        }

        // 全局函数，用于AI聊天
        window.toggleAIChat = toggleAIChat;
        window.handleAIKeyPress = handleAIKeyPress;
        window.sendAIMessage = sendAIMessage;
        window.toggleAISwitch = toggleAISwitch;
    </script>
</body>
</html>
